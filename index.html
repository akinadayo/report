<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>デザイン思考インタビューゲーム</title>
    
    <!-- 
    NOTE: This is a single HTML file application for easy deployment.
    Production warnings are expected and intentional:
    - Tailwind CDN is used instead of PostCSS for simplicity
    - Babel transformer is used for JSX without build step
    これは単一HTMLファイルアプリケーションです。簡単なデプロイのため、
    本番環境での警告は意図的なものです。
    -->
    
    <!-- Tailwind CSS (CDN for single-file deployment) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind CDN warning for single-file deployment
        if (typeof window !== 'undefined' && window.console) {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && args[0].includes('cdn.tailwindcss.com')) return;
                originalWarn.apply(console, args);
            };
        }
    </script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX (required for single-file deployment) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Shared Game Logic (inlined for single-file deployment) -->
    <script>
    (function (root, factory) {
      if (typeof module === 'object' && module.exports) {
        module.exports = factory();
      } else {
        root.GameLogic = factory();
      }
    })(typeof globalThis !== 'undefined' ? globalThis : this, function () {
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

      const defaultOptions = {
        mood: 'normal',
        difficulty: 'normal',
        challengeMode: null,
        currentMission: null,
        scoreHistory: []
      };

      function calculateScore(questionInput, previousContextInput = '', options = {}) {
        const question = (questionInput ?? '').toString();
        const previousContext = (previousContextInput ?? '').toString();
        const {
          mood,
          difficulty,
          challengeMode,
          currentMission,
          scoreHistory
        } = { ...defaultOptions, ...options };

        let breakdown = {
          depth: 0,
          empathy: 0,
          exploration: 0,
          context: 0,
          penalty: 0,
          bonus: 0,
          combo: 0
        };

        const whyCount = (question.match(/なぜ|どうして|どうなって|原因|理由/g) || []).length;
        if (whyCount > 0) {
          breakdown.depth += Math.min(whyCount * 15, 30);
          if (question.includes('本当に') || question.includes('そもそも') || question.includes('根本')) {
            breakdown.depth += 15;
            breakdown.bonus += 10;
          }
        }

        if (Array.isArray(scoreHistory) && scoreHistory.length > 0) {
          const lastScore = scoreHistory[scoreHistory.length - 1];
          if (lastScore >= 70 && whyCount > 0) {
            breakdown.combo = 15;
          }
        }

        if (question.includes('具体的') || question.includes('例えば') || question.includes('どんな')) {
          breakdown.depth += 5;
        }

        if ((question.includes('感じ') || question.includes('思い') || question.includes('気持ち')) &&
            (question.includes('なぜ') || question.includes('どうして'))) {
          breakdown.depth += 7;
        }

        const empathyWords = ['大変', '難しい', '辛い', '嬉しい', '素晴らしい'];
        const hasEmpathy = empathyWords.some(word => question.includes(word));
        if (hasEmpathy && previousContext) {
          breakdown.empathy += 8;
        } else if (hasEmpathy) {
          breakdown.empathy += 3;
        }

        if ((previousContext && question.includes('"')) || question.includes('「')) {
          breakdown.empathy += 5;
        }

        const isClosedQuestion = question.includes('ですか？') ||
          question.includes('ますか？') ||
          !!question.match(/はい|いいえ|Yes|No/i);

        if (!isClosedQuestion) {
          if (question.includes('どのように') || question.includes('どんな') || question.includes('何が')) {
            breakdown.exploration += 10;
          } else {
            breakdown.exploration += 5;
          }
        }

        if (question.includes('もし') || question.includes('仮に') || question.includes('たとえば')) {
          breakdown.exploration += 6;
        }

        if ((question.includes('理想') && question.includes('現実')) ||
            question.includes('ギャップ') ||
            question.includes('違い')) {
          breakdown.exploration += 8;
        }

        if (previousContext) {
          const contextWords = previousContext.split(/[、。！？\s]+/).filter(w => w.length > 2);
          const usedContextWords = contextWords.filter(word => question.includes(word)).length;
          breakdown.context += Math.min(usedContextWords * 3, 10);
        }

        if (question.length > 70) {
          breakdown.penalty -= 12;
        }
        if (question.length < 15) {
          breakdown.penalty -= 15;
        }
        if (question.split('？').length > 2) {
          breakdown.penalty -= 20;
        }
        if (question.includes('はい') || question.includes('いいえ')) {
          breakdown.penalty -= 18;
        }
        if (!question.includes('？')) {
          breakdown.penalty -= 5;
        }
        if (question.includes('ですよね') || question.includes('でしょう？')) {
          breakdown.penalty -= 15;
        }

        const moodMultiplier = {
          open: 1.2,
          normal: 1.0,
          guard: 0.6,
          close: 0.3
        };

        const difficultyMultiplier = {
          easy: 1.2,
          normal: 0.9,
          hard: 0.7,
          expert: 0.5
        };

        let score = Object.values(breakdown).reduce((sum, val) => sum + val, 0);
        const difficultyFactor = difficultyMultiplier[difficulty] ?? difficultyMultiplier.normal;
        const moodFactor = moodMultiplier[mood] ?? moodMultiplier.normal;

        score *= difficultyFactor;
        if (challengeMode === 'noHint') {
          score *= 1.5;
        }
        if (currentMission === 'speedrun') {
          score *= 1.3;
        }

        score = Math.round(score * moodFactor);
        score = clamp(score, 15, 100);

        if (score > 80) {
          if (whyCount < 2 || !question.includes('なぜ')) {
            score = Math.min(score, 70);
          }
        }
        if (score > 90) {
          if (!question.includes('感情') && !question.includes('体験') && !question.includes('なぜ')) {
            score = Math.min(score, 85);
          }
        }

        return { score, breakdown };
      }

      function deriveNextMood(currentMood = 'normal', scoreValue = 50) {
        let mood = currentMood;
        const score = Number.isFinite(scoreValue) ? scoreValue : 50;

        if (score >= 80) {
          if (mood === 'close') mood = 'normal';
          else if (mood === 'guard') mood = 'open';
          else mood = 'open';
        } else if (score >= 60) {
          if (mood === 'close') mood = 'guard';
          else if (mood === 'guard') mood = 'normal';
          else if (mood === 'normal') mood = 'open';
        } else if (score <= 30) {
          if (mood === 'open') mood = 'normal';
          else if (mood === 'normal') mood = 'guard';
          else mood = 'close';
        } else if (score <= 40) {
          if (mood === 'open') mood = 'normal';
          else if (mood === 'normal') mood = 'guard';
        }

        return mood;
      }

      function calculateRank(currentScore = 0, targetScore = 0, scoreHistory = []) {
        const percentage = targetScore > 0 ? (currentScore / targetScore) * 100 : 0;
        const avgScore = Array.isArray(scoreHistory) && scoreHistory.length > 0
          ? scoreHistory.reduce((sum, value) => sum + value, 0) / scoreHistory.length
          : 0;

        if (percentage >= 100 && avgScore >= 85) return 'SSS';
        if (percentage >= 95 && avgScore >= 80) return 'SS';
        if (percentage >= 90 && avgScore >= 75) return 'S';
        if (percentage >= 80 && avgScore >= 70) return 'A';
        if (percentage >= 70 && avgScore >= 60) return 'B';
        if (percentage >= 60 && avgScore >= 50) return 'C';
        if (percentage >= 50 && avgScore >= 40) return 'D';
        return 'E';
      }

      function getAnalysisData(messages = [], scoreHistory = [], insights = [], questionCount = 0) {
        const avgScore = Array.isArray(scoreHistory) && scoreHistory.length > 0
          ? Math.round(scoreHistory.reduce((sum, value) => sum + value, 0) / scoreHistory.length)
          : 0;

        const userMessages = Array.isArray(messages)
          ? messages.filter(m => m && m.type === 'user' && typeof m.content === 'string')
          : [];

        const whyQuestions = userMessages.filter(m => m.content.includes('なぜ')).length;
        const openQuestions = userMessages.filter(m => !m.content.includes('？')).length;

        const totalLength = userMessages.reduce((sum, m) => sum + m.content.length, 0);
        const denominator = Math.max(1, questionCount || userMessages.length);
        const avgLength = Math.round(totalLength / denominator);

        return {
          avgScore,
          whyQuestions,
          openQuestions,
          avgLength,
          totalInsights: Array.isArray(insights) ? insights.length : 0
        };
      }

      function generatePersonaForTopic(selectedTopic = '', options = {}) {
        const rng = typeof options.rng === 'function' ? options.rng : Math.random;
        const maleNames = ['田中太郎', '鈴木一郎', '渡辺健', '山田大輔', '加藤雄介', '小林翔'];
        const femaleNames = ['佐藤花子', '高橋美咲', '伊藤さくら', '山本愛', '中村真由美', '木村優子'];

        let personaConfig = {
          ages: [25, 32, 28, 45, 38, 52, 35, 29, 41],
          jobs: ['エンジニア', 'デザイナー', '営業職', 'マーケター', '教師', '医療従事者', '経営者', 'フリーランス', '公務員'],
          locations: ['東京都心', '神奈川郊外', '地方都市', '大阪市内', '福岡市'],
          families: ['独身', '既婚（子供なし）', '既婚（子供1人）', '既婚（子供2人）', 'シングル（子供1人）'],
          hobbies: ['読書', '映画鑑賞', 'スポーツ', '料理', '旅行', 'ゲーム', '音楽', 'カフェ巡り'],
          painPoints: [],
          hiddenNeeds: []
        };

        if (selectedTopic?.includes('朝') || selectedTopic?.includes('ルーティン')) {
          personaConfig = {
            ages: [28, 35, 42, 30, 45],
            jobs: ['会社員', 'エンジニア', '営業職', 'コンサルタント', '管理職'],
            locations: ['東京都心', '神奈川郊外', '千葉郊外'],
            families: ['既婚（子供1人）', '既婚（子供2人）', '独身', '既婚（子供なし）'],
            hobbies: ['ジョギング', 'ヨガ', '読書', 'コーヒー', '瞑想'],
            painPoints: ['時間不足', '準備の非効率', '家族との調整'],
            hiddenNeeds: ['自分時間の確保', '効率的な朝活', '健康的な習慣']
          };
        } else if (selectedTopic?.includes('リモート') || selectedTopic?.includes('在宅')) {
          personaConfig = {
            ages: [29, 35, 40, 32, 38],
            jobs: ['エンジニア', 'デザイナー', 'マーケター', 'プロジェクトマネージャー', 'データアナリスト'],
            locations: ['東京郊外', '地方都市', '神奈川県', '埼玉県'],
            families: ['既婚（子供1人）', '独身', '既婚（子供なし）', 'ペットと同居'],
            hobbies: ['オンラインゲーム', '動画視聴', '料理', '園芸', 'DIY'],
            painPoints: ['コミュニケーション不足', '運動不足', '仕事とプライベートの境界'],
            hiddenNeeds: ['社会的つながり', '健康維持', 'ワークライフバランス']
          };
        } else if (selectedTopic?.includes('買い物') || selectedTopic?.includes('購買')) {
          // 買い物・購買体験に関するオプション
          options = {
            names: ['山田花子', '田中美咲', '鈴木由美', '佐藤あゆみ'],
            ages: [28, 34, 42, 31],
            jobs: ['事務職', 'パート勤務', 'フリーランス', '主婦'],
            locations: ['東京都内', '千葉県', '神奈川県'],
            families: ['既婚（子供2人）', '独身', '既婚（子供なし）'],
            hobbies: ['料理', 'ハンドメイド', 'カフェ巡り', '節約'],
            painPoints: ['価格比較の手間', '買い物時間の確保', 'ネット vs 実店舗の選択'],
            hiddenNeeds: ['賢い買い物', '時間効率', '満足感のある購買体験']
          };
        }
        
        // ランダム選択関数
        const random = (arr) => arr[Math.floor(Math.random() * arr.length)];
        
        return {
          name: random(options.names),
          gender: options.names[0].includes('花子') || options.names[0].includes('美咲') ? '女性' : '男性',
          age: random(options.ages),
          job: random(options.jobs),
          location: random(options.locations),
          family: random(options.families),
          hobbies: [random(options.hobbies), random(options.hobbies)].filter((v, i, a) => a.indexOf(v) === i),
          personality: {
            traits: ['誠実', '好奇心旺盛', '慎重'],
            communication_style: '丁寧で落ち着いた話し方'
          },
          background: `${selectedTopic}について日々考えている一般的な社会人`,
          painPoints: options.painPoints,
          hiddenNeeds: options.hiddenNeeds,
          currentSituation: `${selectedTopic}についての改善を模索中`
        };
      }
      
      return {
        calculateScore,
        deriveNextMood,
        calculateRank,
        getAnalysisData,
        generatePersonaForTopic
      };
    });
    </script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            margin: 0;
            padding: 0;
        }
        
        /* カスタムスクロールバー */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* アニメーション */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-100%); }
            to { transform: translateX(0); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes ripple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(99, 102, 241, 0.5); }
            50% { box-shadow: 0 0 20px rgba(99, 102, 241, 0.8); }
        }
        
        @keyframes countUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        .slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        .bounce {
            animation: bounce 1s infinite;
        }
        
        .typing-dot {
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        .glow {
            animation: glow 2s infinite;
        }
        
        .float-up {
            animation: floatUp 2s ease-out forwards;
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        .rainbow-bg {
            background: linear-gradient(90deg, #6366F1, #8B5CF6, #EC4899, #6366F1);
            background-size: 300% 100%;
            animation: rainbow 3s linear infinite;
        }
        
        /* リップルエフェクト */
        .ripple {
            position: relative;
            overflow: hidden;
        }
        
        .ripple::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            animation: ripple 0.6s ease-out;
        }
        
        /* グラデーションテキスト */
        .gradient-text {
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* カード影 */
        .card-shadow {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .card-shadow-hover {
            transition: all 0.3s ease;
        }
        
        .card-shadow-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 25px 30px -5px rgba(0, 0, 0, 0.15), 0 15px 15px -5px rgba(0, 0, 0, 0.06);
        }
        
        /* メッセージバブル - LINE風デザイン */
        .message-bubble {
            position: relative;
            padding: 8px 12px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .message-bubble.user {
            background: #00B900;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        
        .message-bubble.ai {
            background: white;
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 4px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        /* プログレスバー */
        .progress-bar {
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar-fill {
            height: 100%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* ダークモード対応 */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #1e1b4b, #312e81);
            }
        }
        
        /* モバイル対応 - LINE風UI */
        @media (max-width: 768px) {
            .message-bubble {
                max-width: 80%;
                font-size: 13px;
                padding: 7px 11px;
                line-height: 1.4;
            }
            
            /* 入力フィールドをLINE風に */
            .mobile-input-area {
                position: fixed;
                bottom: 0;
                bottom: env(safe-area-inset-bottom);
                left: 0;
                right: 0;
                background: #ffffff;
                border-top: 1px solid #e5e7eb;
                padding: 6px 8px;
                padding-bottom: calc(6px + env(safe-area-inset-bottom));
                z-index: 100;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            .mobile-input-field {
                font-size: 16px !important; /* iOS自動ズーム防止 */
                padding: 8px 12px !important;
                border-radius: 20px !important;
                background: #f7f8fa !important;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
            }
            
            /* スコア表示を超コンパクトに */
            .mobile-status-bar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 90;
                background: white;
                padding: 4px 8px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
                height: 36px;
            }
            
            .mobile-compact-score {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 11px;
                height: 100%;
            }
            
            /* チャットエリアの調整 */
            .mobile-chat-area {
                padding-top: 40px !important; /* ステータスバー分の余白 */
                padding-bottom: 70px !important; /* 入力エリア分の余白 */
                padding-left: 8px !important;
                padding-right: 8px !important;
            }
            
            /* ペルソナ情報をコンパクトに */
            .mobile-persona-info {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            /* モバイルペルソナ情報モーダル */
            .mobile-persona-modal {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 350px;
                background: white;
                border-radius: 12px;
                padding: 16px;
                z-index: 200;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            }
            
            .mobile-persona-overlay {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 199;
            }
            
            /* ボタンサイズ調整 */
            .mobile-button {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            /* ステータスバーを非表示 */
            .hide-mobile {
                display: none !important;
            }
            
            /* ビューポート対応 */
            .mobile-viewport {
                height: 100vh;
                height: -webkit-fill-available;
                height: 100dvh;
                height: calc(var(--vh, 1vh) * 100); /* Android Chrome対応 */
                overflow: hidden;
                display: flex;
                flex-direction: column;
                position: relative;
            }
            
            /* iOS Safe Area対応 */
            .safe-area-top {
                padding-top: env(safe-area-inset-top);
            }
            
            .safe-area-bottom {
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            /* キーボード表示時の調整用 */
            .keyboard-visible .mobile-chat-area {
                padding-bottom: 70px !important;
            }
            
            /* スクロール最適化 */
            .smooth-scroll {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
            }
            
            /* 入力フィールドフォーカス時のスタイル */
            input:focus, textarea:focus, select:focus {
                outline: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Android Chrome用の追加調整 */
            @supports (-webkit-appearance: none) and (not (-ms-ime-align: auto)) {
                .mobile-input-field {
                    font-size: 16px !important;
                }
                
                .mobile-viewport {
                    min-height: -webkit-fill-available;
                }
            }
        }
        
        /* ローディングスピナー */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* パーティクルエフェクト用 */
        .particle {
            position: fixed;
            pointer-events: none;
            opacity: 0;
            animation: particle-float 3s ease-out forwards;
        }
        
        @keyframes particle-float {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(var(--x), var(--y)) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--x) * 2), calc(var(--y) * 2)) scale(0.5);
            }
        }
        
        /* トースト通知 */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: slideInRight 0.3s ease-out;
            z-index: 1000;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        
        // Safari/iOS compatible fetch helper
        const safariFetch = async (url, options, timeout = 15000) => {
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            if (isSafari || isIOS) {
                // For Safari/iOS, use Promise.race for timeout
                return Promise.race([
                    fetch(url, options),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timeout')), timeout)
                    )
                ]);
            } else {
                // For other browsers, use AbortController
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    clearTimeout(timeoutId);
                    throw error;
                }
            }
        };
        
        // メインアプリコンポーネント
        const InterviewGame = () => {
            // ゲーム状態管理
            const [gameState, setGameState] = useState('menu'); // menu, persona, playing, result
            const [currentScore, setCurrentScore] = useState(0);
            const [difficulty, setDifficulty] = useState('normal'); // easy, normal, hard, expert
            const [questionCount, setQuestionCount] = useState(0);
            const [maxQuestions, setMaxQuestions] = useState(10);
            
            // スコアシステム（満点なし、純粋な獲得点のみ）
            const [challengeMode, setChallengeMode] = useState(null); // null or specific challenge
            const [talkMeter, setTalkMeter] = useState(0);
            const [mood, setMood] = useState('normal'); // open, normal, guard, close
            const [messages, setMessages] = useState([]);
            const [currentQuestion, setCurrentQuestion] = useState('');
            const [isTyping, setIsTyping] = useState(false);
            const [scoreHistory, setScoreHistory] = useState([]);
            const [insights, setInsights] = useState([]);
            const [bestQuestions, setBestQuestions] = useState([]);
            const [comboCount, setComboCount] = useState(0);
            const [showParticles, setShowParticles] = useState(false);
            const [toasts, setToasts] = useState([]);
            const [achievements, setAchievements] = useState([]);
            const [totalGamesPlayed, setTotalGamesPlayed] = useState(
                parseInt(localStorage.getItem('totalGamesPlayed') || '0')
            );
            const [highScores, setHighScores] = useState(
                JSON.parse(localStorage.getItem('highScores') || '{}')
            );
            const [totalScore, setTotalScore] = useState(
                parseInt(localStorage.getItem('totalScore') || '0')
            );
            const [showDifficultySettings, setShowDifficultySettings] = useState(false);
            const [currentMission, setCurrentMission] = useState(null);
            const [isGeneratingPersona, setIsGeneratingPersona] = useState(false);
            const [showPersonaInfo, setShowPersonaInfo] = useState(false);
            
            // ペルソナ設定
            const [persona, setPersona] = useState(null);
            const [selectedCategory, setSelectedCategory] = useState('');
            const [painPoints, setPainPoints] = useState([]);
            const [selectedPainPoint, setSelectedPainPoint] = useState('');
            const [customPainPoint, setCustomPainPoint] = useState('');
            const [isGeneratingPainPoints, setIsGeneratingPainPoints] = useState(false);
            
            // API設定
            const [apiKey, setApiKey] = useState(() => {
                if (typeof window === 'undefined') return '';
                try {
                    return localStorage.getItem('apiKey') || '';
                } catch (error) {
                    console.warn('Failed to read apiKey from storage:', error);
                    return '';
                }
            });
            const [apiModel, setApiModel] = useState(() => {
                if (typeof window === 'undefined') return 'deepseek/deepseek-chat-v3.1:free';
                try {
                    return localStorage.getItem('apiModel') || 'deepseek/deepseek-chat-v3.1:free';
                } catch (error) {
                    console.warn('Failed to read apiModel from storage:', error);
                    return 'deepseek/deepseek-chat-v3.1:free';
                }
            });
            const [showApiSettings, setShowApiSettings] = useState(false);
            const [apiTested, setApiTested] = useState(() => {
                if (typeof window === 'undefined') return false;
                try {
                    return localStorage.getItem('apiTested') === 'true';
                } catch (error) {
                    console.warn('Failed to read apiTested flag:', error);
                    return false;
                }
            });
            const [apiTesting, setApiTesting] = useState(false);
            const [isMobile, setIsMobile] = useState(false);
            const [keyboardHeight, setKeyboardHeight] = useState(0);
            const [isInputFocused, setIsInputFocused] = useState(false);

            const gameLogic = useMemo(() => window.GameLogic || null, []);

            // Show API settings on first load if no API key
            useEffect(() => {
                if (!apiKey && !localStorage.getItem('APIkey')) {
                    setShowApiSettings(true);
                }
            }, []); // Run only on mount
            
            // Detect mobile device and handle keyboard
            useEffect(() => {
                const checkMobile = () => {
                    setIsMobile(window.innerWidth <= 768);
                };
                
                checkMobile();
                
                // Set custom viewport height for Android Chrome
                const setVH = () => {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                };
                
                setVH();
                window.addEventListener('resize', setVH);
                window.addEventListener('orientationchange', setVH);
                
                // Visual Viewport API for keyboard detection (iOS and Android)
                const handleViewportChange = () => {
                    if (window.visualViewport) {
                        const keyboardHeight = window.innerHeight - window.visualViewport.height;
                        setKeyboardHeight(keyboardHeight);
                        
                        // Add class when keyboard is visible
                        if (keyboardHeight > 50) {
                            document.body.classList.add('keyboard-visible');
                        } else {
                            document.body.classList.remove('keyboard-visible');
                        }
                    }
                };
                
                // iOS specific keyboard handling
                const handleFocusIn = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        setIsInputFocused(true);
                        // スクロール位置は自動スクロール機能に任せる
                        // キーボード表示時の強制スクロールを削除
                    }
                };
                
                const handleFocusOut = () => {
                    setIsInputFocused(false);
                    // Prevent page from staying scrolled up
                    window.scrollTo(0, 0);
                };
                
                window.addEventListener('resize', checkMobile);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', handleViewportChange);
                    window.visualViewport.addEventListener('scroll', handleViewportChange);
                }
                document.addEventListener('focusin', handleFocusIn);
                document.addEventListener('focusout', handleFocusOut);
                
                return () => {
                    window.removeEventListener('resize', checkMobile);
                    window.removeEventListener('resize', setVH);
                    window.removeEventListener('orientationchange', setVH);
                    if (window.visualViewport) {
                        window.visualViewport.removeEventListener('resize', handleViewportChange);
                        window.visualViewport.removeEventListener('scroll', handleViewportChange);
                    }
                    document.removeEventListener('focusin', handleFocusIn);
                    document.removeEventListener('focusout', handleFocusOut);
                };
            }, [messagesEndRef]);

            useEffect(() => {
                if (typeof window === 'undefined') return;
                try {
                    localStorage.setItem('apiKey', apiKey);
                } catch (error) {
                    console.warn('Failed to persist apiKey:', error);
                }
            }, [apiKey]);

            useEffect(() => {
                if (typeof window === 'undefined') return;
                try {
                    localStorage.setItem('apiModel', apiModel);
                } catch (error) {
                    console.warn('Failed to persist apiModel:', error);
                }
            }, [apiModel]);

            useEffect(() => {
                if (typeof window === 'undefined') return;
                try {
                    localStorage.setItem('apiTested', apiTested ? 'true' : 'false');
                } catch (error) {
                    console.warn('Failed to persist apiTested flag:', error);
                }
            }, [apiTested]);
            
            // Refs
            const messagesEndRef = useRef(null);
            const inputRef = useRef(null);
            const chatAreaRef = useRef(null);
            
            // テーマカテゴリー
            const themeCategories = [
                { id: 'commute', title: '通勤・移動', icon: '🚃' },
                { id: 'work', title: '仕事・学習', icon: '💼' },
                { id: 'life', title: '生活・家事', icon: '🏠' },
                { id: 'health', title: '健康・運動', icon: '💪' },
                { id: 'social', title: '人間関係', icon: '👥' },
                { id: 'hobby', title: '趣味・娯楽', icon: '🎮' }
            ];
            
            // ペインポイント生成関数（リトライ機能付き）
            const generatePainPoints = useCallback(async (category, retryCount = 0) => {
                if (!apiKey || !apiTested) {
                    showToast('APIキーを設定してください', 'error');
                    return [];
                }
                
                const maxRetries = 2;
                
                // AI生成
                try {
                    const categoryInfo = themeCategories.find(c => c.id === category);
                    
                    // デバッグ: モデル名を確認
                    console.log('Generating scenario with model:', apiModel);
                    
                    // Sonoma Sky Alpha用に英語プロンプトを使用
                    const isSonoma = apiModel && apiModel.includes('sonoma');
                    
                    const prompt = isSonoma ? 
                        // English prompt for Sonoma Sky Alpha
                        `Generate 3 specific pain points that people commonly experience in the "${categoryInfo.title}" category.

Examples:
- Having difficulty taking buses
- Unable to handle stress in crowded trains
- Can't find the right timing to speak in online meetings

Respond with JSON:
{
  "painPoints": [
    "specific problem 1",
    "specific problem 2",
    "specific problem 3"
  ]
}` :
                        // Japanese prompt for DeepSeek models
                        `${categoryInfo.title}カテゴリーで、一般的な人が抱える具体的な困りごと（ペインポイント）を3つ生成してください。

例：
- バスに乗るのが苦手で困っている
- 満員電車でのストレスが耐えられない
- オンライン会議で発言するタイミングが掴めない

以下のJSON形式で応答:
{
  "painPoints": [
    "具体的な困りごと1",
    "具体的な困りごと2",
    "具体的な困りごと3"
  ]
}`;

                    const systemPrompt = isSonoma ?
                        'You are a helpful assistant. Generate realistic pain points in Japanese. Respond only with valid JSON.' :
                        'リアルで具体的な困りごとを生成してください。JSON形式で応答。';
                    
                    const response = await safariFetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin || 'http://localhost',
                            'X-Title': 'Pain Point Generation'
                        },
                        body: JSON.stringify({
                            model: apiModel || 'deepseek/deepseek-chat-v3.1:free',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: prompt }
                            ],
                            temperature: isSonoma ? 0.5 : 0.8,
                            max_tokens: isSonoma ? 8000 : 2000 // Sonoma: 8000, DeepSeek: 2000
                        })
                    }, 20000); // 20 second timeout for Safari
                    
                    if (!response.ok) {
                        const errorData = await response.text();
                        console.error('API Error Response:', errorData);
                        console.error('Using model:', modelToUse);
                        throw new Error(`API request failed: ${response.status} - ${errorData}`);
                    }
                    
                    const data = await response.json();
                    if (!data.choices || !data.choices[0]) {
                        throw new Error('Invalid API response');
                    }
                    
                    const content = data.choices[0].message.content;
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const parsed = JSON.parse(jsonMatch[0]);
                        return parsed.painPoints || [];
                    }
                    return [];
                } catch (error) {
                    console.error(`Pain point generation error (attempt ${retryCount + 1}):`, error);
                    console.error('Model:', apiModel);
                    
                    // Sonoma Sky Alpha specific debugging
                    if (apiModel === 'openrouter/sonoma-sky-alpha') {
                        console.error('=== Sonoma Sky Alpha Debug Info ===');
                        console.error('Model name:', apiModel);
                        console.error('API Key present:', !!apiKey);
                        console.error('Error details:', error.message);
                        console.error('Full error:', error);
                        console.error('===================================');
                    }
                    
                    if (retryCount < maxRetries) {
                        console.log(`Retrying... (attempt ${retryCount + 2}/${maxRetries + 1})`);
                        showToast(`再試行中... (${retryCount + 2}/${maxRetries + 1})`, 'info');
                        
                        // Wait a bit before retrying
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // Recursive retry
                        return generatePainPoints(category, retryCount + 1);
                    }
                    
                    // All retries failed
                    const errorMsg = apiModel === 'openrouter/sonoma-sky-alpha'
                        ? 'Sonoma Sky Alphaの接続に失敗しました。他のモデルをお試しください。'
                        : 'お題の生成に失敗しました。もう一度お試しください。';
                    showToast(errorMsg, 'error');
                    throw error;
                }
            }, [apiKey, apiModel, apiTested, showToast]);
            
            // AIペルソナ生成機能
            const generatePersonaWithAI = useCallback(async (painPoint) => {
                if (!apiKey || !apiTested) {
                    showToast('AIペルソナ生成にはAPI設定が必要です', 'error');
                    return null;
                }
                
                try {
                    setIsGeneratingPersona(true);
                    showToast('AIがペルソナを生成中...', 'info');
                    
                    console.log('Generating persona with model:', apiModel);
                    
                    const promptText = `
以下の困りごと（ペインポイント）を抱えている架空の人物（ペルソナ）を作成してください。
ペインポイント: ${painPoint}

リアルで自然なペルソナを作成し、必ず完全な有効なJSON形式で出力してください。
文章は短くまとめ、JSONが途中で切れないようにしてください：
{
  "name": "日本人の名前（フルネーム）",
  "gender": "男性または女性",
  "age": 年齢（20-60の整数）,
  "job": "具体的な職業",
  "location": "具体的な居住地（都市名や地域）",
  "family": "家族構成（独身、既婚など具体的に）",
  "hobbies": ["趣味1", "趣味2"],
  "personality": {
    "traits": ["性格特性1", "性格特性2", "性格特性3"],
    "communication_style": "コミュニケーションスタイル"
  },
  "background": "背景（1-2文で簡潔に）",
  "painPoints": ["課題1", "課題2", "課題3"],
  "hiddenNeeds": ["ニーズ1", "ニーズ2"],
  "currentSituation": "現状（1-2文で簡潔に）"
}

重要：
- 与えられたペインポイントを必ず主要な悩みとして含めてください
- painPoints（課題）の1つ目は必ず「${painPoint}」にしてください
- 残り2つは関連する具体的な問題を追加してください
- hiddenNeeds（隠れたニーズ）はこのペインポイントを解決したい本当の理由を2つ挙げてください
- ペルソナはこのペインポイントに実際に困っている人として振る舞います
- 矛盾した回答（例：困っているのに「問題ない」と答える）は絶対にしません`;
                    
                    const response = await safariFetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin || 'http://localhost',
                            'X-Title': 'Interview Game'
                        },
                        body: JSON.stringify({
                            model: apiModel,
                            messages: [
                                { 
                                    role: 'system', 
                                    content: 'あなたはペルソナ作成の専門家です。リアルで詳細な人物設定を作成し、必ずJSON形式で応答してください。' 
                                },
                                { role: 'user', content: promptText }
                            ],
                            temperature: 0.9,
                            max_tokens: apiModel === 'openrouter/sonoma-sky-alpha' ? 8000 : 3000 // Sonoma: 8000, DeepSeek: 3000
                        })
                    }, 20000);
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('API Response:', data);
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Invalid API response structure');
                    }
                    
                    const content = data.choices[0].message.content || '';
                    
                    // 空の応答をチェック
                    if (!content || content.trim().length < 10) {
                        console.log('Empty or too short API response, using fallback');
                        throw new Error('Empty API response');
                    }
                    
                    // JSONパース試行（改善版）
                    let parsedPersona;
                    try {
                        // JSONブロックを抽出
                        let jsonStr = content;
                        
                        // マークダウンコードブロックを除去
                        if (content.includes('```json')) {
                            const match = content.match(/```json\n?([\s\S]*?)\n?```/);
                            if (match) jsonStr = match[1];
                        } else if (content.includes('```')) {
                            const match = content.match(/```\n?([\s\S]*?)\n?```/);
                            if (match) jsonStr = match[1];
                        }
                        
                        // 不完全なJSONを検出して修復
                        if (!jsonStr.trim().endsWith('}')) {
                            console.log('Incomplete JSON detected, attempting to fix...');
                            
                            // 最後の完全なプロパティまでで切る
                            const lines = jsonStr.split('\n');
                            let lastValidLine = -1;
                            
                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (line.endsWith(',') || line.endsWith('}') || line.endsWith(']')) {
                                    lastValidLine = i;
                                    break;
                                }
                            }
                            
                            if (lastValidLine >= 0) {
                                jsonStr = lines.slice(0, lastValidLine + 1).join('\n');
                                // 最後のカンマを削除
                                if (jsonStr.trim().endsWith(',')) {
                                    jsonStr = jsonStr.trim().slice(0, -1);
                                }
                            }
                            
                            // 開いているブラケットを数える
                            const openBraces = (jsonStr.match(/\{/g) || []).length;
                            const closeBraces = (jsonStr.match(/\}/g) || []).length;
                            const openBrackets = (jsonStr.match(/\[/g) || []).length;
                            const closeBrackets = (jsonStr.match(/\]/g) || []).length;
                            
                            // 不足している閉じ括弧を追加
                            for (let i = 0; i < openBrackets - closeBrackets; i++) {
                                jsonStr += ']';
                            }
                            
                            // 不足している閉じ波括弧を追加
                            for (let i = 0; i < openBraces - closeBraces; i++) {
                                jsonStr += '}';
                            }
                        }
                        
                        // JSONオブジェクトを抽出
                        const jsonMatch = jsonStr.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            jsonStr = jsonMatch[0];
                        }
                        
                        // エスケープされた引用符を修正（最初に処理）
                        jsonStr = jsonStr.replace(/\\"/g, '"');
                        
                        // 一般的なJSON形式エラーを修正
                        jsonStr = jsonStr
                            .replace(/,\s*}/g, '}')  // 末尾のカンマを削除
                            .replace(/,\s*]/g, ']')  // 配列末尾のカンマを削除
                            .replace(/"\s*:\s*"([^"]*)"([^,}\]]*[,}\]])/g, '": "$1"$2')  // コロン後のスペースを修正
                            .replace(/\n\s*\n/g, '\n')  // 余分な改行を削除
                            .replace(/,(\s*[}\]])/g, '$1'); // 最後のカンマを削除
                        
                        console.log('Attempting to parse JSON:', jsonStr.substring(0, 500) + '...');
                        parsedPersona = JSON.parse(jsonStr);
                        
                    } catch (e) {
                        console.error('Persona JSON Parse Error:', e, '\nContent:', content);
                        
                        // パースエラー時は基本的なペルソナを作成
                        parsedPersona = {
                            name: '山田太郎',
                            gender: '男性',
                            age: 35,
                            job: '会社員',
                            location: '東京都',
                            family: '既婚（子供1人）',
                            hobbies: ['読書', '散歩'],
                            personality: {
                                traits: ['真面目', '協調的', '慎重'],
                                communication_style: '丁寧で落ち着いた話し方'
                            },
                            background: `${painPoint}で困っている社会人です。`,
                            painPoints: [painPoint, '時間不足', 'ストレス'],
                            hiddenNeeds: ['問題解決', '快適な生活'],
                            currentSituation: `現在、${painPoint}という課題を解決したいと考えています。`
                        };
                        
                        console.log('Using fallback persona due to parse error');
                    }
                    
                    // 必須フィールドの確認とデフォルト値設定
                    const persona = {
                        name: parsedPersona.name || '田中太郎',
                        gender: parsedPersona.gender || '男性',
                        age: parsedPersona.age || 35,
                        job: parsedPersona.job || '会社員',
                        location: parsedPersona.location || '東京都',
                        family: parsedPersona.family || '独身',
                        hobbies: parsedPersona.hobbies || ['読書', '映画鑑賞'],
                        personality: {
                            openness: Math.random(),
                            empathy: Math.random(),
                            guardedness: Math.random(),
                            traits: parsedPersona.personality?.traits || [],
                            communication_style: parsedPersona.personality?.communication_style || '普通'
                        },
                        background: parsedPersona.background || '',
                        painPoints: parsedPersona.painPoints || [],
                        hiddenNeeds: parsedPersona.hiddenNeeds || [],
                        currentSituation: parsedPersona.currentSituation || '',
                        currentMood: 'normal'
                    };
                    
                    // AI生成成功の場合はメッセージを表示
                    if (parsedPersona && parsedPersona.name && parsedPersona.name !== '山田太郎') {
                        showToast('AIペルソナの生成が完了しました！', 'success');
                    } else {
                        showToast('AIペルソナを簡易生成しました', 'info');
                    }
                    
                    return persona;
                    
                } catch (error) {
                    console.error('AI Persona Generation Error:', error);
                    showToast('AIペルソナ生成でエラーが発生しました。基本ペルソナを使用します。', 'warning');
                    
                    // エラー時も基本的なペルソナを返す
                    const fallbackPainPoint = 'インタビューが苦手で困っている';
                    return {
                        name: '鈴木花子',
                        gender: '女性',
                        age: 30,
                        job: '会社員',
                        location: '東京都',
                        family: '独身',
                        hobbies: ['カフェ巡り', '読書'],
                        personality: {
                            openness: 0.7,
                            empathy: 0.8,
                            guardedness: 0.3,
                            traits: ['社交的', '好奇心旺盛', '前向き'],
                            communication_style: '親しみやすい話し方'
                        },
                        background: `都内で働く会社員です。${fallbackPainPoint}`,
                        painPoints: [fallbackPainPoint, '時間管理', 'コミュニケーション不足'],
                        hiddenNeeds: ['自信を持ちたい', '効果的な質問スキル'],
                        currentSituation: `${fallbackPainPoint}という状況を改善したいと思っています。`,
                        currentMood: 'normal'
                    };
                } finally {
                    setIsGeneratingPersona(false);
                }
            }, [apiKey, apiModel, apiTested, showToast, generatePersona]);
            
            // ペルソナ生成（手動フォールバック）
            const generatePersona = useCallback((painPoint) => {
                // ペインポイントに基づいたデフォルトペルソナを生成
                return {
                    name: '山田太郎',
                    gender: '男性',
                    age: 35,
                    job: '会社員',
                    location: '東京都',
                    family: '独身',
                    hobbies: ['読書', '映画鑑賞'],
                    personality: {
                        openness: 0.5,
                        empathy: 0.5,
                        guardedness: 0.5
                    },
                    hiddenNeeds: ['ストレスフリーな生活', '効率的な解決策'],
                    painPoints: [painPoint, '時間的余裕のなさ', 'ストレスの蓄積'],
                    currentMood: 'normal',
                    background: `${painPoint}で日々困っている会社員`,
                    currentSituation: `${painPoint}をどうにか解決したいと思っている`
                };
            }, [gameLogic]);
            
            // スコア計算（改善版 - 共通ロジックを利用）
            const calculateScore = useCallback((question, previousContext) => {
                if (gameLogic?.calculateScore) {
                    return gameLogic.calculateScore(question, previousContext, {
                        mood,
                        difficulty,
                        challengeMode,
                        currentMission,
                        scoreHistory
                    });
                }
                return {
                    score: 50,
                    breakdown: {
                        depth: 0,
                        empathy: 0,
                        exploration: 0,
                        context: 0,
                        penalty: 0,
                        bonus: 0,
                        combo: 0
                    }
                };
            }, [gameLogic, mood, difficulty, challengeMode, currentMission, scoreHistory]);
            
            // APIテスト機能
            const testAPI = useCallback(async () => {
                if (!apiKey) {
                    showToast('APIキーを入力してください', 'error');
                    return false;
                }
                
                setApiTesting(true);
                try {
                    const requestBody = {
                        model: apiModel,
                        messages: [
                            { role: 'user', content: 'テスト接続です。簡潔に応答してください。' }
                        ],
                        max_tokens: 100,
                        temperature: 0.7
                    };
                    
                    console.log('Testing API with model:', apiModel);
                    
                    const response = await safariFetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin || 'http://localhost',
                            'X-Title': 'Interview Game'
                        },
                        body: JSON.stringify(requestBody)
                    }, 10000);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorMsg = `API Error: ${response.status}`;
                        
                        try {
                            const errorJson = JSON.parse(errorText);
                            errorMsg = errorJson.error?.message || errorMsg;
                        } catch {
                            errorMsg = errorText || errorMsg;
                        }
                        
                        // Sonoma Sky Alpha specific error handling
                        if (apiModel === 'openrouter/sonoma-sky-alpha') {
                            console.error('=== Sonoma Sky Alpha Connection Failed ===');
                            console.error('Status:', response.status);
                            console.error('Error:', errorMsg);
                            console.error('Headers:', response.headers);
                            
                            if (response.status === 403 || response.status === 401) {
                                errorMsg = 'Sonoma Sky Alphaへのアクセス権限がありません。APIキーを確認してください。';
                            } else if (response.status === 404) {
                                errorMsg = 'Sonoma Sky Alphaモデルが見つかりません。';
                            }
                        }
                        
                        throw new Error(errorMsg);
                    }
                    
                    const data = await response.json();
                    if (data.choices && data.choices[0]) {
                        setApiTested(true);
                        showToast('API接続成功！ゲームを開始できます', 'success');
                        return true;
                    }
                    throw new Error('Invalid API response');
                    
                } catch (error) {
                    console.error('API Test Error:', error);
                    
                    // Sonoma Sky Alpha fallback suggestion
                    if (apiModel === 'openrouter/sonoma-sky-alpha') {
                        setApiTested(false);
                        showToast('Sonoma Sky Alphaの接続に失敗しました。DeepSeekモデルの使用を推奨します。', 'error');
                        
                        // Suggest switching to DeepSeek
                        setTimeout(() => {
                            if (window.confirm('DeepSeek Chat V3.1に切り替えますか？')) {
                                setApiModel('deepseek/deepseek-chat-v3.1:free');
                                showToast('DeepSeek Chat V3.1に切り替えました。再度テストしてください。', 'info');
                            }
                        }, 500);
                    } else {
                        setApiTested(false);
                        showToast(`API接続失敗: ${error.message}`, 'error');
                    }
                    return false;
                } finally {
                    setApiTesting(false);
                }
            }, [apiKey, apiModel, showToast]);
            
            // AI応答生成
            const generateAIResponse = useCallback(async (question) => {
                setIsTyping(true);

                // APIキーがない、またはテストされていない場合はエラー
                if (!apiKey || !apiTested) {
                    setIsTyping(false);
                    showToast('APIが設定されていません。設定画面でAPIをテストしてください。', 'error');
                    return {
                        response: 'APIが設定されていません。',
                        score: 0,
                        breakdown: {},
                        newMood: mood,
                        insight: null
                    };
                }
                
                console.log('Generating response with model:', apiModel);
                
                // OpenRouter API呼び出し（リトライ機能付き）
                const maxRetries = 3;
                let retryCount = 0;
                let lastError = null;
                
                while (retryCount < maxRetries) {
                    try {
                        if (retryCount > 0) {
                            console.log(`Retry attempt ${retryCount} of ${maxRetries}`);
                            showToast(`再試行中... (${retryCount}/${maxRetries})`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)); // 増分待機
                        }
                        
                        // プロンプトを短くして確実に応答を得る
                        const moodDescription = {
                            open: '開放的で、前向きに話したがっている。解決への期待を持っている',
                            normal: '普通に会話している。適度な協力姿勢',
                            guard: '少し警戒しているが、話す意欲はある',
                            close: '心を閉ざし気味だが、良い質問には反応したい'
                        };
                        
                        const conversationHistory = messages.slice(-4).map(m => 
                            `${m.type === 'user' ? 'インタビュアー' : persona.name}: ${m.content}`
                        ).join('\n');
                        
                        const promptText = `あなたは${persona.name}（${persona.age}歳、${persona.gender}）です。
職業: ${persona.job}
場所: ${persona.location}
家族: ${persona.family}
趣味: ${persona.hobbies.join('、')}
悩み・課題: ${persona.painPoints && persona.painPoints.length > 0 ? persona.painPoints.join('、') : '特になし'}
隠れたニーズ: ${persona.hiddenNeeds && persona.hiddenNeeds.length > 0 ? persona.hiddenNeeds.join('、') : '特になし'}
現在の気分: ${moodDescription[mood]}
話題: ${persona.painPoints && persona.painPoints[0] ? persona.painPoints[0] : '日常の困りごと'}

重要な指示:
- 悩みは抱えているが、完全にネガティブではなく、解決への意欲も持っています
- 時には前向きな面や、小さな喜びも表現してください
- 人間味のあるバランスの取れた応答をしてください
- 良い質問には素直に喜び、協力的な態度を示してください
- 隠れたニーズは直接言わず、それとなく示してください

会話履歴:
${conversationHistory}

インタビュアーの質問: ${question}

質問を評価して応答してください。評価基準:
- 深掘り力（なぜ・どうしてを聞いているか）
- 共感力（感情への理解を示しているか）
- 探索力（オープンな質問か）
- 文脈力（前の会話を踏まえているか）

以下のJSON形式で応答:
{
  "response": "ペルソナとして自然で人間味のある返答（1-3文）。時には感謝や期待も表現",
  "score": 質問の評価点(0-100),
  "scoreBreakdown": {
    "depth": 深掘り点(0-35),
    "empathy": 共感点(0-25),
    "exploration": 探索点(0-30),
    "context": 文脈点(0-10)
  },
  "newMood": "新しい気分(open/normal/guard/close) - 良い質問なら開放的に、悪い質問なら閉じていく",
  "insight": "重要な発見があれば記載（なければnull）",
  "moodReason": "気分が変わった理由（1文）"
}`;
                    
                    const response = await safariFetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin || 'http://localhost',
                            'X-Title': 'Interview Game'
                        },
                        body: JSON.stringify({
                            model: apiModel,
                            messages: [
                                { 
                                    role: 'system', 
                                    content: 'あなたは指定されたペルソナになりきって応答します。重要：リアルで共感できる人間として振る舞ってください。悩みはあるが前向きな面も持ち、インタビュアーとの建設的な対話を望んでいます。過度にネガティブにならず、時には感謝や期待、小さな喜びも表現してください。必ず有効なJSON形式で応答し、JSONのプロパティ名はダブルクォートで囲んでください。' 
                                },
                                { role: 'user', content: promptText }
                            ],
                            temperature: 0.7,
                            max_tokens: apiModel === 'openrouter/sonoma-sky-alpha' ? 8000 : 4000 // Sonoma: 8000, DeepSeek: 4000
                        })
                    }, 20000);
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('API Response:', data);
                    
                    // 応答が空または無効な場合のチェック
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        console.error('Invalid API response structure:', data);
                        throw new Error('Invalid API response structure');
                    }
                    
                    // contentが存在しない、または空の場合
                    if (!data.choices[0].message.content || data.choices[0].message.content.trim() === '') {
                        console.error('Empty content in API response:', data);
                        throw new Error('Empty content in API response');
                    }
                    
                    const content = data.choices[0].message.content;
                    
                    // 空の内容をチェック
                    if (!content || content.trim() === '') {
                        console.log('Empty content received from API, will retry...');
                        throw new Error('Empty API response');
                    }
                    
                    // JSONパース試行
                    let parsedResponse;
                    try {
                        // JSONブロックを抽出（マークダウンのコードブロックに対応）
                        const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/) || 
                                         content.match(/```\n?([\s\S]*?)\n?```/) ||
                                         content.match(/\{[\s\S]*\}/);
                        
                        let jsonStr = jsonMatch ? 
                            (jsonMatch[1] || jsonMatch[0]).replace(/```json\n?|```\n?|```/g, '') : 
                            content;
                        
                        // よくあるJSONエラーを修正
                        jsonStr = jsonStr
                            .replace(/" "/g, '""') // 余分なスペースを削除
                            .replace(/,\s*\}/g, '}') // 末尾のカンマを削除
                            .replace(/,\s*\]/g, ']') // 配列末尾のカンマを削除
                            .replace(/\n\s*"/g, '\n"') // 改行後の余分なスペースを削除
                            .replace(/" "([a-zA-Z]+)":/g, '"$1":'); // プロパティ名前の余分な引用符を修正
                        
                        // 不完全なJSONを修復する試み
                        // 文字化けや切断されたJSONを検出して修復
                        if (jsonStr.includes('ins　') || jsonStr.includes('となります') || 
                            jsonStr.includes('本当に') || /[^\x00-\x7F]{3,}$/.test(jsonStr)) {
                            console.warn('Detected corrupted JSON, attempting repair');
                            
                            // 最後の有効なJSON要素を探す
                            const lastValidPositions = [
                                jsonStr.lastIndexOf('"}'),
                                jsonStr.lastIndexOf('",'),
                                jsonStr.lastIndexOf(': "'),
                                jsonStr.lastIndexOf('],'),
                                jsonStr.lastIndexOf('},')
                            ].filter(pos => pos > 0);
                            
                            if (lastValidPositions.length > 0) {
                                const cutoffPoint = Math.max(...lastValidPositions);
                                jsonStr = jsonStr.substring(0, cutoffPoint + 2);
                            }
                        }
                        
                        // 文字列の途中で切れている場合の修復
                        const lastQuoteIndex = jsonStr.lastIndexOf('"');
                        const secondLastQuoteIndex = jsonStr.lastIndexOf('"', lastQuoteIndex - 1);
                        if (lastQuoteIndex > secondLastQuoteIndex && 
                            !jsonStr.substring(lastQuoteIndex).includes('}')) {
                            // 未完了の文字列を閉じる
                            jsonStr = jsonStr.substring(0, lastQuoteIndex + 1);
                        }
                        
                        // JSONが不完全に見える場合の修復
                        const openBraces = (jsonStr.match(/\{/g) || []).length;
                        const closeBraces = (jsonStr.match(/\}/g) || []).length;
                        const openBrackets = (jsonStr.match(/\[/g) || []).length;
                        const closeBrackets = (jsonStr.match(/\]/g) || []).length;
                        
                        // 配列を閉じる
                        if (openBrackets > closeBrackets) {
                            jsonStr += ']'.repeat(openBrackets - closeBrackets);
                        }
                        
                        // オブジェクトを閉じる
                        if (openBraces > closeBraces) {
                            jsonStr += '}'.repeat(openBraces - closeBraces);
                        }
                        
                        // 空のJSONチェック
                        if (!jsonStr || jsonStr.trim() === '') {
                            throw new Error('Empty JSON string');
                        }
                        
                        parsedResponse = JSON.parse(jsonStr);
                        
                        // 必須フィールドの検証とデフォルト値設定
                        if (!parsedResponse.response) {
                            throw new Error('No response text found');
                        }
                        
                        // スコアが存在しない、または不正な値の場合は計算する
                        if (typeof parsedResponse.score !== 'number' || parsedResponse.score < 0 || parsedResponse.score > 100) {
                            const { score, breakdown } = calculateScore(question, messages.length > 0 ? messages[messages.length - 1].content : '');
                            parsedResponse.score = score;
                            parsedResponse.breakdown = breakdown;
                        }
                        
                        // breakdownが不完全な場合は再計算
                        if (!parsedResponse.breakdown || typeof parsedResponse.breakdown !== 'object') {
                            const { score, breakdown } = calculateScore(question, messages.length > 0 ? messages[messages.length - 1].content : '');
                            parsedResponse.breakdown = breakdown;
                        }
                        
                        // newMoodの検証と修正
                        if (!parsedResponse.newMood || !['open', 'normal', 'guard', 'close'].includes(parsedResponse.newMood)) {
                            // スコアに基づいて気分を更新
                            let newMood = mood;
                            const score = parsedResponse.score || 50;
                            
                            // より積極的な気分変化
                            if (score >= 80) {
                                // 素晴らしい質問 - 大幅に開放的に
                                if (mood === 'close') newMood = 'normal';
                                else if (mood === 'guard') newMood = 'open';
                                else newMood = 'open';
                            } else if (score >= 60) {
                                // 良い質問 - 少し開放的に
                                if (mood === 'close') newMood = 'guard';
                                else if (mood === 'guard') newMood = 'normal';
                                else if (mood === 'normal') newMood = 'open';
                            } else if (score <= 30) {
                                // 悪い質問 - 閉じていく
                                if (mood === 'open') newMood = 'normal';
                                else if (mood === 'normal') newMood = 'guard';
                                else newMood = 'close';
                            } else if (score <= 40) {
                                // やや悪い質問
                                if (mood === 'open') newMood = 'normal';
                                else if (mood === 'normal') newMood = 'guard';
                            }
                            parsedResponse.newMood = newMood;
                        }
                        
                        // 気分変化の理由を追加
                        if (parsedResponse.newMood !== mood && !parsedResponse.moodReason) {
                            const reasons = {
                                'open': ['質問が的確で話しやすくなりました', '理解してもらえていると感じます'],
                                'normal': ['普通に話せそうです', '少し様子を見ています'],
                                'guard': ['ちょっと答えにくい質問でした', '少し警戒しています'],
                                'close': ['この話題は避けたいです', '質問の意図が分かりません']
                            };
                            parsedResponse.moodReason = reasons[parsedResponse.newMood]?.[Math.floor(Math.random() * 2)] || '';
                        }
                        
                        // insightのチェック
                        if (parsedResponse.score > 80 && !parsedResponse.insight) {
                            const insights = [
                                '本質的な課題を発見',
                                '隠れたニーズを特定',
                                '感情の根源を発見',
                                '理想と現実のギャップを発見'
                            ];
                            parsedResponse.insight = insights[Math.floor(Math.random() * insights.length)];
                        }
                        
                    } catch (e) {
                        console.error('JSON Parse Error:', e, 'Content:', content);
                        
                        // JSONパースに失敗した場合、内容から必要な情報を抽出する試み
                        let extractedResponse = null;
                        
                        // responseフィールドを探す
                        const responseMatch = content.match(/"response"\s*:\s*"([^"]+)"/);
                        if (responseMatch) {
                            extractedResponse = responseMatch[1];
                        }
                        
                        // それでも見つからない場合は最初の日本語文を使用
                        if (!extractedResponse) {
                            const japaneseMatch = content.match(/[ぁ-んァ-ヶー一-龠].+[。！？]/);
                            if (japaneseMatch) {
                                extractedResponse = japaneseMatch[0];
                            }
                        }
                        
                        // フォールバック応答の生成
                        const { score, breakdown } = calculateScore(question, messages.length > 0 ? messages[messages.length - 1].content : '');
                        parsedResponse = {
                            response: extractedResponse || 'そうですね、それは興味深い質問ですね。もう少し詳しくお聞かせください。',
                            score: score,
                            breakdown: breakdown,
                            newMood: mood,
                            insight: null,
                            moodReason: 'API応答の解析に問題がありました'
                        };
                        
                        // ユーザーに軽いエラー通知
                        console.warn('JSON parsing failed, using extracted response:', extractedResponse);
                    }
                    
                    console.log('Final parsed response:', parsedResponse);
                        setIsTyping(false);
                        return parsedResponse;
                        
                    } catch (error) {
                        lastError = error;
                        retryCount++;
                        console.error(`API Error (attempt ${retryCount}):`, error);
                        
                        if (retryCount >= maxRetries) {
                            console.error('Max retries reached, using fallback');
                            break;
                        }
                    }
                }
                
                // すべてのリトライが失敗した場合
                console.error('All retries failed, using fallback response');
                showToast('API応答の取得に失敗しました。フォールバック応答を使用します', 'warning');
                
                const fallbackResponses = [
                    'そうですね、それについてもう少し詳しく教えていただけますか？',
                    'なるほど、興味深いお話ですね。具体的にはどのような感じでしょうか？',
                    'その点は確かに重要ですね。普段はどのように対処されていますか？'
                ];
                
                const { score, breakdown } = calculateScore(question, messages.length > 0 ? messages[messages.length - 1].content : '');
                
                setIsTyping(false);
                return {
                    response: fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)],
                    score: Math.max(20, score),
                    breakdown,
                    newMood: mood,
                    insight: null
                };
            }, [apiKey, apiModel, mood, persona, calculateScore, messages, gameLogic]);
            
            // 質問送信処理
            const handleSubmitQuestion = useCallback(async () => {
                if (!currentQuestion.trim() || questionCount >= maxQuestions) return;
                
                // 質問内容を保存してから、すぐに入力欄をクリア
                const questionText = currentQuestion;
                setCurrentQuestion('');
                
                // Clear input immediately and manage focus
                if (inputRef.current) {
                    inputRef.current.value = '';
                    // Only blur on mobile to hide keyboard after sending
                    if (isMobile) {
                        inputRef.current.blur();
                    }
                }
                
                // Scroll to bottom after sending message
                // ユーザーがメッセージを送信した後は必ずスクロール
                scrollToLatest();
                
                const userMessage = {
                    type: 'user',
                    content: questionText,
                    timestamp: new Date()
                };
                
                setMessages(prev => [...prev, userMessage]);
                const newQuestionCount = questionCount + 1;
                setQuestionCount(newQuestionCount);
                
                // ユーザーがメッセージを送信した時は必ず最新を表示
                scrollToLatest();
                
                const aiResponse = await generateAIResponse(questionText);
                
                // スコア更新
                const newScore = currentScore + aiResponse.score;
                setCurrentScore(newScore);
                setScoreHistory(prev => [...prev, aiResponse.score]);
                setTalkMeter(prev => Math.min(100, prev + (aiResponse.score / 10)));
                setMood(aiResponse.newMood);
                
                // 高得点時の演出（より頻繁に発生）
                if (aiResponse.score >= 60) { // 閾値を下げる
                    const newComboCount = comboCount + 1;
                    setComboCount(newComboCount);
                    if (newComboCount >= 2) { // 2回目から表示
                        showToast(`🔥 ${newComboCount}連続コンボ！ +${newComboCount * 20}ボーナス`, 'success');
                        setCurrentScore(prev => prev + newComboCount * 20);
                    }
                    triggerParticles();
                } else {
                    if (comboCount > 2) {
                        showToast('💔 コンボが途切れました', 'warning');
                    }
                    setComboCount(0);
                }
                
                // スペシャルボーナス
                if (aiResponse.score >= 90) {
                    showToast('⭐ パーフェクト質問！ +50ボーナス', 'success');
                    setCurrentScore(prev => prev + 50);
                    // 特別なエフェクト
                    document.body.style.animation = 'pulse 0.5s';
                    setTimeout(() => document.body.style.animation = '', 500);
                }
                
                // ベスト質問の記録
                if (aiResponse.score >= 80) {
                    setBestQuestions(prev => [...prev, { question: currentQuestion, score: aiResponse.score }]
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 3));
                }
                
                // インサイト発見
                if (aiResponse.insight) {
                    setInsights(prev => [...prev, aiResponse.insight]);
                    showToast('💡 インサイト発見！', 'success');
                    checkAchievements('insight');
                }
                
                // アチーブメントチェック
                checkAchievements('score', aiResponse.score);
                if (questionCount === 0) {
                    checkAchievements('firstQuestion');
                }
                if (comboCount >= 3) {
                    checkAchievements('combo3');
                }
                if (comboCount >= 5) {
                    checkAchievements('combo5');
                }
                
                const aiMessage = {
                    type: 'ai',
                    content: aiResponse.response,
                    score: aiResponse.score,
                    breakdown: aiResponse.breakdown,
                    timestamp: new Date()
                };
                
                setMessages(prev => [...prev, aiMessage]);
                
                // AIが応答した時も最新を表示
                scrollToLatest();
                
                // スコア詳細をコンソールに表示（デバッグ用）
                console.log('Question Score Details:', {
                    question: questionText,
                    score: aiResponse.score,
                    breakdown: aiResponse.breakdown,
                    mood: mood,
                    newMood: aiResponse.newMood
                });
                
                // ゲーム終了チェック（質問数のみで判定）
                console.log(`Question ${newQuestionCount} of ${maxQuestions} completed`);
                if (newQuestionCount >= maxQuestions) {
                    console.log('Game ending - starting analysis...');
                    // コンボカウントをリセット
                    setComboCount(0);
                    // ゲーム完了時のアチーブメント
                    checkAchievements('gameComplete');
                    const newTotal = totalGamesPlayed + 1;
                    setTotalGamesPlayed(newTotal);
                    localStorage.setItem('totalGamesPlayed', newTotal.toString());
                    
                    // 隠しアチーブメントチェック
                    if (insights.length >= 5) {
                        checkAchievements('hiddenGenius');
                    }
                    
                    // スピードランチェック（ゲーム開始時刻を記録する必要がある）
                    const gameTime = Date.now() - (window.gameStartTime || Date.now());
                    if (gameTime < 180000) { // 3分以内
                        checkAchievements('speedDemon');
                    }
                    
                    // ハイスコア更新
                    const finalScore = currentScore + aiResponse.score;
                    const newHighScores = { ...highScores };
                    if (!newHighScores[difficulty] || finalScore > newHighScores[difficulty]) {
                        newHighScores[difficulty] = finalScore;
                        setHighScores(newHighScores);
                        localStorage.setItem('highScores', JSON.stringify(newHighScores));
                        showToast('🏆 新記録達成！', 'success');
                    }
                    
                    // 総スコア更新
                    const newTotalScore = totalScore + finalScore;
                    setTotalScore(newTotalScore);
                    localStorage.setItem('totalScore', newTotalScore.toString());
                    
                    // エキスパートモード特別アチーブメント
                    if (difficulty === 'expert' && finalScore >= 800) {
                        checkAchievements('expertMaster');
                    }
                    
                    // パーフェクトゲームチェック
                    const allHighScores = scoreHistory.every(s => s >= 70);
                    if (allHighScores && currentMission === 'perfect') {
                        checkAchievements('perfectGame');
                    }
                    
                    setTimeout(async () => {
                        console.log('Starting AI analysis...');
                        // AIで会話を分析
                        try {
                            await generateAIAnalysis();
                            console.log('AI analysis completed, switching to result screen');
                        } catch (error) {
                            console.error('AI analysis failed:', error);
                        }
                        setGameState('result');
                    }, 2000);
                }
            }, [currentQuestion, questionCount, maxQuestions, generateAIResponse, comboCount, currentScore, generateAIAnalysis, checkAchievements, totalGamesPlayed, highScores, difficulty, totalScore, currentMission, scoreHistory, showToast, insights]);
            
            // パーティクルエフェクト
            const triggerParticles = useCallback(() => {
                setShowParticles(true);
                setTimeout(() => setShowParticles(false), 3000);
            }, []);
            
            // トースト通知
            const showToast = useCallback((message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => {
                    setToasts(prev => prev.filter(t => t.id !== id));
                }, 3000);
            }, []);
            
            // アチーブメントシステム
            const checkAchievements = useCallback((type, value = null) => {
                const newAchievements = [];
                
                switch(type) {
                    case 'firstQuestion':
                        if (!localStorage.getItem('achievement_firstQuestion')) {
                            newAchievements.push({
                                id: 'firstQuestion',
                                name: '🎯 初めての質問',
                                description: '最初の質問を送信しました'
                            });
                        }
                        break;
                    case 'score':
                        if (value >= 95 && !localStorage.getItem('achievement_perfect')) {
                            newAchievements.push({
                                id: 'perfect',
                                name: '⭐ パーフェクト質問',
                                description: '95点以上の質問を達成（高難易度）'
                            });
                        }
                        break;
                    case 'combo3':
                        if (!localStorage.getItem('achievement_combo3')) {
                            newAchievements.push({
                                id: 'combo3',
                                name: '🔥 3連続コンボ',
                                description: '3回連続で良い質問を達成'
                            });
                        }
                        break;
                    case 'combo5':
                        if (!localStorage.getItem('achievement_combo5')) {
                            newAchievements.push({
                                id: 'combo5',
                                name: '💥 5連続コンボマスター',
                                description: '5回連続で良い質問を達成'
                            });
                        }
                        break;
                    case 'insight':
                        if (!localStorage.getItem('achievement_insight')) {
                            newAchievements.push({
                                id: 'insight',
                                name: '💡 インサイト発見者',
                                description: '重要なインサイトを発見'
                            });
                        }
                        break;
                    case 'expertMaster':
                        if (!localStorage.getItem('achievement_expertMaster')) {
                            newAchievements.push({
                                id: 'expertMaster',
                                name: '👑 エキスパートマスター',
                                description: 'エキスパートモードで900点以上達成'
                            });
                        }
                        break;
                    case 'perfectGame':
                        if (!localStorage.getItem('achievement_perfectGame')) {
                            newAchievements.push({
                                id: 'perfectGame',
                                name: '💎 パーフェクトゲーム',
                                description: '全質問80点以上でクリア'
                            });
                        }
                        break;
                    case 'hiddenGenius':
                        if (!localStorage.getItem('achievement_hiddenGenius')) {
                            newAchievements.push({
                                id: 'hiddenGenius',
                                name: '🧠 隠れた天才',
                                description: '1回のゲームで5つ以上のインサイト発見'
                            });
                        }
                        break;
                    case 'speedDemon':
                        if (!localStorage.getItem('achievement_speedDemon')) {
                            newAchievements.push({
                                id: 'speedDemon',
                                name: '⚡ スピードデーモン',
                                description: '3分以内にゲームクリア'
                            });
                        }
                        break;
                    case 'legendaryInterviewer':
                        if (!localStorage.getItem('achievement_legendaryInterviewer') && totalGamesPlayed >= 50) {
                            newAchievements.push({
                                id: 'legendaryInterviewer',
                                name: '🌟 伝説のインタビュアー',
                                description: '50回プレイ＆平均スコア80点以上'
                            });
                        }
                        break;
                    case 'secretEnding':
                        // イースターエッグ: 特定の質問パターンで解除
                        if (!localStorage.getItem('achievement_secretEnding')) {
                            newAchievements.push({
                                id: 'secretEnding',
                                name: '🔮 秘密の終わり',
                                description: '??? を発見した'
                            });
                        }
                        break;
                    case 'gameComplete':
                        const gamesPlayed = totalGamesPlayed + 1;
                        if (gamesPlayed === 1) {
                            newAchievements.push({
                                id: 'firstGame',
                                name: '🎮 ゲームデビュー',
                                description: '初めてゲームを完了'
                            });
                        }
                        if (gamesPlayed === 10) {
                            newAchievements.push({
                                id: 'veteran',
                                name: '🏅 ベテランインタビュアー',
                                description: '10回ゲームをプレイ'
                            });
                        }
                        break;
                }
                
                // 新しいアチーブメントを記録
                newAchievements.forEach(achievement => {
                    localStorage.setItem(`achievement_${achievement.id}`, 'true');
                    setAchievements(prev => [...prev, achievement]);
                    showToast(`🏆 アチーブメント解除: ${achievement.name}`, 'success');
                });
            }, [showToast, totalGamesPlayed]);
            
            // ゲーム開始（ペルソナ確認画面へ）
            const startGame = useCallback(async () => {
                const finalPainPoint = customPainPoint || selectedPainPoint;
                if (!finalPainPoint) {
                    showToast('困りごとを選択するか、カスタム入力してください', 'warning');
                    return;
                }
                
                if (!apiTested) {
                    showToast('先にAPIをテストしてください', 'warning');
                    return;
                }
                
                const aiPersona = await generatePersonaWithAI(finalPainPoint);
                const personaCandidate = aiPersona || generatePersona(finalPainPoint);
                setPersona(personaCandidate);
                if (typeof window !== 'undefined') {
                    window.__PLAYWRIGHT_PERSONA = personaCandidate;
                }
                setShowPersonaInfo(false);
                setGameState('persona');
            }, [selectedPainPoint, customPainPoint, generatePersona, generatePersonaWithAI, showToast, apiTested]);
            
            // インタビュー開始（ペルソナ確認後）
            const startInterview = useCallback(() => {
                if (!persona) return;
                
                const mainPainPoint = persona.painPoints && persona.painPoints[0] ? persona.painPoints[0] : '困りごと';

                setGameState('playing');
                setCurrentScore(0);
                setQuestionCount(0);
                setTalkMeter(0);
                setMood('normal');
                
                window.gameStartTime = Date.now();
                
                // ペインポイントを自然な表現に変換
                const naturalPainPoint = (() => {
                    // 不要な語尾を除去
                    let cleaned = mainPainPoint
                        .replace(/で困っている|に困っている|てしまう|してしまう|困っている/g, '')
                        .replace(/、/g, '')
                        .trim();
                    
                    // 長すぎる場合は要約的に
                    if (cleaned.length > 40) {
                        // 最初の主要な問題部分を抽出
                        const mainIssue = cleaned.match(/^([^、。]+)/);
                        if (mainIssue) {
                            return mainIssue[1] + 'こと';
                        }
                        // それでも長い場合は30文字でカット
                        return cleaned.substring(0, 30) + '...こと';
                    }
                    
                    // 「こと」で終わっていない場合は追加
                    if (!cleaned.endsWith('こと')) {
                        return cleaned + 'こと';
                    }
                    
                    return cleaned;
                })();
                
                setMessages([{
                    type: 'ai',
                    content: `こんにちは！${persona.name}です。今日はお時間をいただきありがとうございます。実は最近、${naturalPainPoint}で少し悩んでいて...。何かアドバイスをいただけたら嬉しいです。よろしくお願いします！`,
                    timestamp: new Date()
                }]);
                setScoreHistory([]);
                setInsights([]);
                setBestQuestions([]);
                setComboCount(0);
                setShowPersonaInfo(false);
                if (typeof window !== 'undefined') {
                    window.__PLAYWRIGHT_STATE = 'playing';
                }
            }, [persona]);

            useEffect(() => {
                if (typeof window !== 'undefined') {
                    window.__PLAYWRIGHT_FORCE_RESULT = async () => {
                        await generateAIAnalysis();
                        setGameState('result');
                    };
                    window.__PLAYWRIGHT_STATE = gameState;
                }
            }, [generateAIAnalysis, gameState]);

            // ゲームリセット
            const resetGame = useCallback(() => {
                setGameState('menu');
                setCurrentScore(0);
                setQuestionCount(0);
                setTalkMeter(0);
                setMood('normal');
                setMessages([]);
                setCurrentQuestion('');
                setScoreHistory([]);
                setInsights([]);
                setBestQuestions([]);
                setComboCount(0);
                setPersona(null);
                setSelectedPainPoint('');
                setCustomPainPoint('');
                setShowPersonaInfo(false);
                if (typeof window !== 'undefined') {
                    window.__PLAYWRIGHT_STATE = 'menu';
                }
            }, []);
            
            // スマートな自動スクロール（ユーザーが最下部にいる時のみ）
            const [isUserScrolling, setIsUserScrolling] = React.useState(false);
            const [shouldAutoScroll, setShouldAutoScroll] = React.useState(true);
            
            // スクロール位置を監視
            const checkIfAtBottom = useCallback(() => {
                if (!chatAreaRef.current) return true;
                const { scrollTop, scrollHeight, clientHeight } = chatAreaRef.current;
                // 最下部から100px以内なら「最下部にいる」と判定
                return scrollHeight - scrollTop - clientHeight < 100;
            }, []);
            
            // ユーザーがスクロールした時
            const handleScroll = useCallback(() => {
                if (chatAreaRef.current) {
                    const isAtBottom = checkIfAtBottom();
                    setShouldAutoScroll(isAtBottom);
                }
            }, [checkIfAtBottom]);
            
            // 新しいメッセージが追加された時の自動スクロール
            useEffect(() => {
                // 最下部にいる場合、または初回表示時のみ自動スクロール
                if (shouldAutoScroll && messagesEndRef.current) {
                    setTimeout(() => {
                        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }, 100);
                }
            }, [messages, shouldAutoScroll]);
            
            // 新しいメッセージ送信時は必ずスクロール
            const scrollToLatest = useCallback(() => {
                setShouldAutoScroll(true);
                setTimeout(() => {
                    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }, 100);
            }, []);
            
            // 気分に応じた背景色変更
            const getMoodColor = useCallback(() => {
                switch(mood) {
                    case 'open': return 'from-green-400 to-blue-500';
                    case 'normal': return 'from-blue-400 to-purple-500';
                    case 'guard': return 'from-yellow-400 to-orange-500';
                    case 'close': return 'from-red-400 to-pink-500';
                    default: return 'from-blue-400 to-purple-500';
                }
            }, [mood]);
            
            // 結果画面のランク計算（総合スコアと平均スコアで判定）
            const calculateRank = useCallback(() => {
                const avgScore = scoreHistory.length > 0 ? 
                    scoreHistory.reduce((a, b) => a + b, 0) / scoreHistory.length : 0;
                
                // 総合スコアと平均スコアの両方を考慮
                if (currentScore >= 1500 && avgScore >= 95) return 'SSS';
                if (currentScore >= 1200 && avgScore >= 90) return 'SS';
                if (currentScore >= 1000 && avgScore >= 85) return 'S';
                if (currentScore >= 800 && avgScore >= 80) return 'A';
                if (currentScore >= 600 && avgScore >= 70) return 'B';
                if (currentScore >= 400 && avgScore >= 60) return 'C';
                if (currentScore >= 200 && avgScore >= 50) return 'D';
                return 'E';
            }, [currentScore, scoreHistory]);
            
            // 詳細な分析とアドバイス生成
            const generateDetailedAnalysis = useCallback(() => {
                const avgScore = scoreHistory.length > 0 ? 
                    scoreHistory.reduce((a, b) => a + b, 0) / scoreHistory.length : 0;
                
                // 質問パターン分析
                const questionPatterns = messages.filter(m => m.type === 'user').map(m => {
                    const q = m.content;
                    return {
                        hasWhy: q.includes('なぜ') || q.includes('どうして'),
                        hasHow: q.includes('どのように') || q.includes('どうやって'),
                        hasFeel: q.includes('感じ') || q.includes('思い'),
                        isOpen: !q.includes('ですか？') && !q.includes('ますか？'),
                        length: q.length
                    };
                });
                
                const whyQuestions = questionPatterns.filter(p => p.hasWhy).length;
                const openQuestions = questionPatterns.filter(p => p.isOpen).length;
                const avgLength = questionPatterns.reduce((sum, p) => sum + p.length, 0) / questionPatterns.length;
                
                // 強みの分析
                const strengths = [];
                if (whyQuestions >= 5) {
                    strengths.push({
                        title: '深掘り力が優秀',
                        detail: `${whyQuestions}回の「なぜ」質問で本質に迫る姿勢が素晴らしいです。相手の表面的な回答に満足せず、根本原因を探求する習慣が身についています。`
                    });
                }
                if (openQuestions >= 7) {
                    strengths.push({
                        title: 'オープンクエスチョンの活用',
                        detail: `${openQuestions}回のオープン質問を使用。相手に自由に話してもらう環境を作れています。これにより予想外の発見が生まれやすくなります。`
                    });
                }
                if (avgScore >= 70) {
                    strengths.push({
                        title: '質問の質が高い',
                        detail: `平均${Math.round(avgScore)}点という高得点。相手の心理状態を読み取り、適切なタイミングで適切な質問ができています。`
                    });
                }
                if (comboCount >= 3) {
                    strengths.push({
                        title: '流れを作る力',
                        detail: '連続して良い質問ができており、会話の流れを上手にコントロールできています。相手が話しやすい雰囲気を維持できています。'
                    });
                }
                
                // 改善点の分析（より具体的に）
                const improvements = [];
                if (whyQuestions < 3) {
                    improvements.push({
                        title: '「なぜ」をもっと活用',
                        detail: '表面的な事実だけでなく、その背景にある理由や動機を探りましょう。',
                        practice: '5 Whys手法：1つの回答に対して5回「なぜ」を繰り返し、本質的な原因に到達する練習をしましょう。',
                        examples: [
                            '「なぜその方法を選んだのですか？」',
                            '「そもそもなぜその問題が起きたと思いますか？」',
                            '「その時なぜそう感じたのか、理由を教えていただけますか？」'
                        ]
                    });
                }
                if (avgLength > 60) {
                    improvements.push({
                        title: '質問を簡潔に',
                        detail: `平均${Math.round(avgLength)}文字は長すぎます。相手が理解しやすい20-40文字程度の質問を心がけましょう。`,
                        practice: '質問を作った後、削れる言葉がないか見直す習慣をつけましょう。',
                        examples: [
                            '❌ 悪い例：「普段の休日はどのような感じで過ごされることが多いですか？また、理想的な休日の過ごし方があれば教えてください」',
                            '✅ 良い例：「休日はどう過ごされていますか？」→「理想の休日は？」'
                        ]
                    });
                }
                if (openQuestions < 5) {
                    improvements.push({
                        title: 'オープンクエスチョンを増やす',
                        detail: 'Yes/Noで答えられる質問が多いです。相手が自由に話せる質問を増やしましょう。',
                        practice: 'クローズド質問をオープン質問に変換する練習をしましょう。',
                        examples: [
                            '❌「満足していますか？」',
                            '✅「どんな点に満足していますか？」',
                            '✅「何が一番の課題だと感じていますか？」'
                        ]
                    });
                }
                if (avgScore < 50) {
                    improvements.push({
                        title: '相手の気持ちに寄り添う',
                        detail: '相手の感情や状況への共感が不足しています。',
                        practice: '共感を示してから質問する習慣をつけましょう。',
                        examples: [
                            '「それは大変でしたね。その時どう対処されたんですか？」',
                            '「なるほど、〜ということですね。もう少し詳しく教えてください」',
                            '「確かにその気持ちわかります。他にも似た経験はありますか？」'
                        ]
                    });
                }
                
                // 次回の課題（具体例付き）
                const challenges = [];
                if (insights.length < 2) {
                    challenges.push({
                        title: '隠れたニーズの発見',
                        approach: '相手が明言していない潜在的なニーズを見つけましょう。',
                        techniques: [
                            '理想と現実のギャップを探る：「理想的にはどうありたいですか？」',
                            '感情の変化に注目：「その前後で気持ちに変化はありましたか？」',
                            '矛盾を深掘り：「先ほど〜とおっしゃいましたが、今の話と違いがあるようですが？」'
                        ]
                    });
                }
                
                if (!bestQuestions.length || (bestQuestions[0] && bestQuestions[0].score < 85)) {
                    challenges.push({
                        title: '90点超えの質問に挑戦',
                        approach: '本質的な深掘りと具体性を組み合わせた質問を作りましょう。',
                        techniques: [
                            '「そもそもなぜその状況になったと思いますか？きっかけを具体的に教えてください」',
                            '「なぜそれが一番重要だと感じるのですか？他の選択肢と比べて何が違いましたか？」',
                            '「その問題の根本原因は何だと思いますか？なぜそう考えるのですか？」'
                        ]
                    });
                }
                
                challenges.push({
                    title: '感情の深層を探る',
                    approach: '事実だけでなく、感情とその理由を深く掘り下げましょう。',
                    techniques: [
                        '「その時どんな気持ちでしたか？なぜそう感じたと思いますか？」',
                        '「一番辛かった/嬉しかったのはどんな瞬間でしたか？」',
                        '「その経験から、自分について何か発見はありましたか？」'
                    ]
                });
                
                return {
                    strengths,
                    improvements,
                    challenges,
                    stats: {
                        avgScore: Math.round(avgScore),
                        whyQuestions,
                        openQuestions,
                        avgLength: Math.round(avgLength),
                        totalInsights: insights.length
                    }
                };
            }, [scoreHistory, messages, comboCount, insights, bestQuestions]);
            
            // AI分析用のデータを取得
            const getAnalysisData = useCallback(() => {
                if (gameLogic?.getAnalysisData) {
                    return gameLogic.getAnalysisData(messages, scoreHistory, insights, questionCount);
                }
                return {
                    avgScore: 0,
                    whyQuestions: 0,
                    openQuestions: 0,
                    avgLength: 0,
                    totalInsights: insights.length
                };
            }, [gameLogic, messages, scoreHistory, insights, questionCount]);
            
            // メニュー画面
            const renderMenu = () => (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-2xl w-full fade-in relative">
                        {/* 設定アイコン */}
                        <button
                            onClick={() => setShowApiSettings(true)}
                            className="absolute top-6 right-6 p-2 rounded-lg hover:bg-gray-100 transition-colors group"
                            title="API設定"
                        >
                            <div className="relative">
                                <svg className="w-6 h-6 text-gray-600 group-hover:text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                {/* API設定状態インジケーター */}
                                {apiTested ? (
                                    <div className="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 rounded-full border-2 border-white"></div>
                                ) : (
                                    <div className="absolute -bottom-1 -right-1 w-3 h-3 bg-red-500 rounded-full border-2 border-white"></div>
                                )}
                            </div>
                        </button>
                        
                        <h1 className="text-4xl font-bold text-center mb-2 gradient-text">
                            デザイン思考インタビューゲーム
                        </h1>
                        <p className="text-gray-600 text-center mb-8">
                            AIペルソナにインタビューして、隠れたニーズを発見しよう！
                        </p>
                        
                        <div className="space-y-6">
                            {/* 難易度とチャレンジ設定 */}
                            <div>
                                <h3 className="text-lg font-semibold mb-3">🎮 難易度設定</h3>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                                    <button
                                        onClick={() => {
                                            setDifficulty('easy');
                                            setMaxQuestions(15);
                                            showToast('イージーモード設定', 'info');
                                            console.log('Set Easy Mode: maxQuestions=15');
                                            if (typeof window !== 'undefined') {
                                                window.__DEBUG_MAX_QUESTIONS = 15;
                                            }
                                        }}
                                        className={`p-2 rounded-lg border-2 transition-all ${
                                            difficulty === 'easy' 
                                                ? 'border-green-500 bg-green-50' 
                                                : 'border-gray-200 hover:border-green-300'
                                        }`}
                                    >
                                        <div className="text-green-600 font-bold text-sm">イージー</div>
                                        <div className="text-xs text-gray-600">15問まで</div>
                                    </button>
                                    <button
                                        onClick={() => {
                                            setDifficulty('normal');
                                            setMaxQuestions(10);
                                            showToast('ノーマルモード設定', 'info');
                                            console.log('Set Normal Mode: maxQuestions=10');
                                            if (typeof window !== 'undefined') {
                                                window.__DEBUG_MAX_QUESTIONS = 10;
                                            }
                                        }}
                                        className={`p-2 rounded-lg border-2 transition-all ${
                                            difficulty === 'normal' 
                                                ? 'border-blue-500 bg-blue-50' 
                                                : 'border-gray-200 hover:border-blue-300'
                                        }`}
                                    >
                                        <div className="text-blue-600 font-bold text-sm">ノーマル</div>
                                        <div className="text-xs text-gray-600">10問まで</div>
                                    </button>
                                    <button
                                        onClick={() => {
                                            setDifficulty('hard');
                                            setMaxQuestions(8);
                                            showToast('ハードモード設定', 'warning');
                                            console.log('Set Hard Mode: maxQuestions=8');
                                            if (typeof window !== 'undefined') {
                                                window.__DEBUG_MAX_QUESTIONS = 8;
                                            }
                                        }}
                                        className={`p-2 rounded-lg border-2 transition-all ${
                                            difficulty === 'hard' 
                                                ? 'border-orange-500 bg-orange-50' 
                                                : 'border-gray-200 hover:border-orange-300'
                                        }`}
                                    >
                                        <div className="text-orange-600 font-bold text-sm">ハード</div>
                                        <div className="text-xs text-gray-600">8問まで</div>
                                    </button>
                                    <button
                                        onClick={() => {
                                            setDifficulty('expert');
                                            setMaxQuestions(6);
                                            showToast('⚡ エキスパートモード起動！', 'error');
                                            console.log('Set Expert Mode: maxQuestions=6');
                                            if (typeof window !== 'undefined') {
                                                window.__DEBUG_MAX_QUESTIONS = 6;
                                            }
                                        }}
                                        className={`p-2 rounded-lg border-2 transition-all ${
                                            difficulty === 'expert' 
                                                ? 'border-red-500 bg-red-50 animate-pulse' 
                                                : 'border-gray-200 hover:border-red-300'
                                        }`}
                                    >
                                        <div className="text-red-600 font-bold text-sm">エキスパート</div>
                                        <div className="text-xs text-gray-600">6問まで</div>
                                    </button>
                                </div>
                                
                                {/* チャレンジミッション */}
                                {difficulty === 'expert' && (
                                    <div className="p-3 bg-gradient-to-r from-red-50 to-orange-50 rounded-lg mb-3 fade-in">
                                        <div className="text-sm font-bold text-red-700 mb-2">🏆 エキスパートチャレンジ</div>
                                        <div className="grid gap-2">
                                            <label className="flex items-center cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    onChange={(e) => setChallengeMode(e.target.checked ? 'noHint' : null)}
                                                    className="mr-2"
                                                />
                                                <span className="text-xs">ノーヒントモード (スコア×1.5)</span>
                                            </label>
                                            <label className="flex items-center cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    onChange={(e) => setCurrentMission(e.target.checked ? 'speedrun' : null)}
                                                    className="mr-2"
                                                />
                                                <span className="text-xs">スピードラン - 3分以内クリア (スコア×2)</span>
                                            </label>
                                            <label className="flex items-center cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    onChange={(e) => setCurrentMission(e.target.checked ? 'perfect' : null)}
                                                    className="mr-2"
                                                />
                                                <span className="text-xs">パーフェクトラン - 全質問70点以上 (特別称号)</span>
                                            </label>
                                        </div>
                                    </div>
                                )}
                            </div>
                            
                            <div>
                                <h3 className="text-lg font-semibold mb-3">1. テーマカテゴリーを選択</h3>
                                <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                                    {themeCategories.map(cat => (
                                        <button
                                            key={cat.id}
                                            onClick={async () => {
                                                if (!isGeneratingPainPoints) {
                                                    setSelectedCategory(cat.id);
                                                    setIsGeneratingPainPoints(true);
                                                    try {
                                                        const points = await generatePainPoints(cat.id);
                                                        if (points && points.length > 0) {
                                                            setPainPoints(points);
                                                        } else {
                                                            // Empty result, clear selection to allow retry
                                                            setSelectedCategory(null);
                                                            setPainPoints([]);
                                                        }
                                                    } catch (error) {
                                                        console.error('All retries failed:', error);
                                                        // Reset selection to allow user to try again
                                                        setSelectedCategory(null);
                                                        setPainPoints([]);
                                                    } finally {
                                                        setIsGeneratingPainPoints(false);
                                                    }
                                                }
                                            }}
                                            disabled={isGeneratingPainPoints}
                                            className={`p-4 rounded-lg border-2 transition-all ${
                                                isGeneratingPainPoints 
                                                    ? 'opacity-50 cursor-not-allowed' 
                                                    : 'card-shadow-hover'
                                            } ${
                                                selectedCategory === cat.id 
                                                    ? 'border-purple-500 bg-purple-50' 
                                                    : 'border-gray-200 hover:border-purple-300'
                                            }`}
                                        >
                                            <div className="text-2xl mb-1">{cat.icon}</div>
                                            <div className="font-medium text-sm">{cat.title}</div>
                                        </button>
                                    ))}
                                </div>
                            </div>
                            
                            {/* ペインポイント生成中のローディング */}
                            {isGeneratingPainPoints && (
                                <div className="fade-in">
                                    <div className="flex items-center justify-center py-8">
                                        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
                                        <span className="ml-3 text-gray-600">お題を生成中...</span>
                                    </div>
                                </div>
                            )}
                            
                            {selectedCategory && painPoints.length > 0 && !isGeneratingPainPoints && (
                                <div className="fade-in">
                                    <h3 className="text-lg font-semibold mb-3">2. 困りごとを選択</h3>
                                    <div className="space-y-2">
                                        {painPoints.map((point, index) => (
                                            <button
                                                key={index}
                                                onClick={() => setSelectedPainPoint(point)}
                                                className={`w-full text-left p-4 rounded-lg border-2 transition-all ${
                                                    selectedPainPoint === point
                                                        ? 'border-purple-500 bg-purple-50'
                                                        : 'border-gray-200 hover:border-purple-300'
                                                }`}
                                            >
                                                <div className="font-medium">{point}</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}
                            
                            <div>
                                <h3 className="text-lg font-semibold mb-3">カスタム困りごと</h3>
                                <input
                                    type="text"
                                    value={customPainPoint}
                                    onChange={(e) => {
                                        setCustomPainPoint(e.target.value);
                                        setSelectedPainPoint(''); // カスタム入力時は選択をクリア
                                    }}
                                    placeholder="具体的な困りごとを入力（例：バスに乗るのが苦手で困っている）"
                                    className="w-full p-3 border-2 border-gray-200 rounded-lg focus:border-purple-500 focus:outline-none transition-colors"
                                />
                            </div>
                            
                            <div className="flex gap-3">
                                <button
                                    onClick={startGame}
                                    disabled={!apiTested || isGeneratingPersona}
                                    className={`w-full py-3 px-6 rounded-lg font-medium transition-all transform ${
                                        apiTested && !isGeneratingPersona
                                            ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600 hover:scale-105' 
                                            : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                    }`}
                                >
                                    {isGeneratingPersona ? 'ペルソナ生成中...' : apiTested ? 'ゲーム開始' : 'APIテストが必要'}
                                </button>
                            </div>
                            
                        </div>
                    </div>
                    
                    {/* API設定モーダル */}
                    {showApiSettings && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 fade-in">
                            <div className="bg-white rounded-xl p-6 max-w-md w-full mx-4">
                                <h2 className="text-xl font-bold mb-4">API設定</h2>
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">OpenRouter APIキー</label>
                                        <input
                                            type="password"
                                            value={apiKey}
                                            onChange={(e) => {
                                                setApiKey(e.target.value);
                                                setApiTested(false);
                                            }}
                                            placeholder="sk-or-..."
                                            className="w-full p-2 border rounded focus:border-purple-500 focus:outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">モデル</label>
                                        <select
                                            value={apiModel}
                                            onChange={(e) => {
                                                setApiModel(e.target.value);
                                                setApiTested(false);
                                            }}
                                            className="w-full p-2 border rounded focus:border-purple-500 focus:outline-none"
                                        >
                                            <option value="deepseek/deepseek-chat-v3.1:free">DeepSeek Chat V3.1 (Free)</option>
                                            <option value="openrouter/sonoma-sky-alpha">Sonoma Sky Alpha (Free)</option>
                                            <option value="deepseek/deepseek-chat-v3-0324:free">DeepSeek Chat V3 (Free)</option>
                                        </select>
                                    </div>
                                    <div className="flex gap-2 items-center">
                                        <button
                                            onClick={testAPI}
                                            disabled={apiTesting}
                                            className={`flex-1 py-2 px-4 rounded-lg font-medium transition-all ${
                                                apiTested
                                                    ? 'bg-green-500 text-white hover:bg-green-600'
                                                    : !apiKey
                                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                                        : 'bg-blue-500 text-white hover:bg-blue-600'
                                            }`}
                                        >
                                            {apiTesting ? 'テスト中...' : apiTested ? '✓ 接続成功' : 'APIをテスト'}
                                        </button>
                                        {apiTested && (
                                            <button
                                                onClick={() => setShowApiSettings(false)}
                                                className="py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
                                            >
                                                閉じる
                                            </button>
                                        )}
                                    </div>
                                    {!apiTested && (
                                        <p className="text-xs text-red-500">
                                            ※APIテストに成功するまでゲームを開始できません
                                        </p>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
            
            // ゲーム画面
            const renderGame = () => {
                return (
                <div className={`min-h-screen flex flex-col ${isMobile ? 'mobile-viewport' : ''}`}>
                    {/* ステータスバー */}
                    <div className={`bg-white shadow-lg ${isMobile ? 'mobile-status-bar' : 'p-4'}`}>
                        <div className="max-w-6xl mx-auto">
                            <div className={isMobile ? 'mobile-compact-score' : 'grid grid-cols-2 md:grid-cols-4 gap-4'}>
                                {isMobile ? (
                                    // モバイル用コンパクト表示
                                    <>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => setShowPersonaInfo(!showPersonaInfo)}
                                                className="p-1.5 bg-blue-500 text-white rounded-full"
                                                title="ペルソナ情報"
                                            >
                                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                    <path d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"/>
                                                </svg>
                                            </button>
                                            <div className="flex items-center gap-1">
                                                <span className="text-[11px]">
                                                    {mood === 'open' && '😊'}
                                                    {mood === 'normal' && '😐'}
                                                    {mood === 'guard' && '😔'}
                                                    {mood === 'close' && '😤'}
                                                </span>
                                                <span className="text-[12px] font-bold text-purple-600">{currentScore}点</span>
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="flex gap-0.5">
                                                {[...Array(Math.min(maxQuestions, 10))].map((_, i) => (
                                                    <div
                                                        key={i}
                                                        className={`w-2 h-2 rounded-full ${
                                                            i < questionCount 
                                                                ? 'bg-gray-300' 
                                                                : 'bg-purple-500'
                                                        }`}
                                                    />
                                                ))}
                                            </div>
                                            <span className="text-[11px] text-gray-500">
                                                残{maxQuestions - questionCount}
                                            </span>
                                        </div>
                                    </>
                                ) : (
                                    // デスクトップ用通常表示
                                    <>
                                        <div>
                                            <div className="text-sm text-gray-500 mb-1">話したい度</div>
                                            <div className="progress-bar">
                                                <div 
                                                    className={`progress-bar-fill bg-gradient-to-r ${getMoodColor()}`}
                                                    style={{ width: `${talkMeter}%` }}
                                                />
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-sm text-gray-500 mb-1">スコア</div>
                                            <div className="text-2xl font-bold">
                                                {currentScore}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                点
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-sm text-gray-500 mb-1">残り質問</div>
                                            <div className="flex gap-1">
                                                {[...Array(maxQuestions)].map((_, i) => (
                                                    <div
                                                        key={i}
                                                        className={`w-3 h-3 rounded-full ${
                                                            i < questionCount 
                                                                ? 'bg-gray-300' 
                                                                : 'bg-purple-500'
                                                        }`}
                                                    />
                                                ))}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-sm text-gray-500 mb-1">気分</div>
                                            <div className="flex items-center gap-2">
                                                <span className="text-2xl">
                                                    {mood === 'open' && '😊'}
                                                    {mood === 'normal' && '😐'}
                                                    {mood === 'guard' && '😔'}
                                                    {mood === 'close' && '😤'}
                                                </span>
                                                <span className="text-xs text-gray-600">
                                                    {mood === 'open' && '開放的'}
                                                    {mood === 'normal' && '普通'}
                                                    {mood === 'guard' && '警戒'}
                                                    {mood === 'close' && '閉鎖的'}
                                                </span>
                                            </div>
                                        </div>
                                    </>
                                )}
                            </div>
                            
                            {/* ペルソナ情報表示ボタン - モバイルでは非表示 */}
                            {!isMobile && (
                                <div className="mt-3 flex justify-between items-center">
                                    <button
                                        onClick={() => setShowPersonaInfo(!showPersonaInfo)}
                                        className="px-4 py-2 bg-gradient-to-r from-blue-500 to-purple-500 text-white rounded-lg text-sm font-medium hover:from-blue-600 hover:to-purple-600 transition-all"
                                    >
                                        {showPersonaInfo ? '👤 ペルソナ情報を隠す' : '👤 ペルソナ情報を見る'}
                                    </button>
                                    <div className="text-sm text-gray-600">
                                        相手: <strong>{persona?.name}</strong> ({persona?.age}歳 / {persona?.job})
                                    </div>
                                </div>
                            )}
                            
                            {/* ペルソナ詳細情報パネル */}
                            {showPersonaInfo && persona && (
                                isMobile ? (
                                    // モバイル用モーダル
                                    <>
                                        <div className="mobile-persona-overlay" onClick={() => setShowPersonaInfo(false)} />
                                        <div className="mobile-persona-modal">
                                            <div className="flex justify-between items-center mb-3">
                                                <h3 className="text-lg font-bold">ペルソナ情報</h3>
                                                <button
                                                    onClick={() => setShowPersonaInfo(false)}
                                                    className="p-1 rounded-full hover:bg-gray-100"
                                                >
                                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                    </svg>
                                                </button>
                                            </div>
                                            <div className="space-y-2 text-sm">
                                                <div className="flex justify-between">
                                                    <span className="text-gray-500">名前:</span>
                                                    <span className="font-medium">{persona.name}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-500">年齢:</span>
                                                    <span className="font-medium">{persona.age}歳 / {persona.gender}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-500">職業:</span>
                                                    <span className="font-medium">{persona.job}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-500">居住地:</span>
                                                    <span className="font-medium">{persona.location}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span className="text-gray-500">家族:</span>
                                                    <span className="font-medium">{persona.family}</span>
                                                </div>
                                                {persona.currentSituation && (
                                                    <div className="pt-2 mt-2 border-t">
                                                        <div className="text-gray-500 mb-1">現在の状況:</div>
                                                        <div className="text-xs">{persona.currentSituation}</div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </>
                                ) : (
                                    // デスクトップ用パネル
                                <div className="mt-3 p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border border-blue-200 fade-in">
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        <div>
                                            <div className="text-xs text-gray-500">名前</div>
                                            <div className="font-medium">{persona.name}</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-gray-500">年齢・性別</div>
                                            <div className="font-medium">{persona.age}歳 / {persona.gender}</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-gray-500">職業</div>
                                            <div className="font-medium">{persona.job}</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-gray-500">居住地</div>
                                            <div className="font-medium">{persona.location}</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-gray-500">家族</div>
                                            <div className="font-medium">{persona.family}</div>
                                        </div>
                                        <div>
                                            <div className="text-xs text-gray-500">趣味</div>
                                            <div className="font-medium">{persona.hobbies?.join('、')}</div>
                                        </div>
                                        {persona.personality?.traits && (
                                            <div className="md:col-span-2">
                                                <div className="text-xs text-gray-500">性格</div>
                                                <div className="font-medium">{persona.personality.traits.join('、')}</div>
                                            </div>
                                        )}
                                    </div>
                                    {persona.currentSituation && (
                                        <div className="mt-3 p-3 bg-white rounded">
                                            <div className="text-xs text-gray-500 mb-1">現在の状況</div>
                                            <div className="text-sm">{persona.currentSituation}</div>
                                        </div>
                                    )}
                                </div>
                                )
                            )}
                            
                            {/* ベスト質問表示 - モバイルでは非表示 */}
                            {!isMobile && bestQuestions.length > 0 && (
                                <div className="mt-4 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg">
                                    <div className="text-sm font-bold text-purple-700 mb-2">🏆 優秀な質問</div>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
                                        {bestQuestions.slice(0, 3).map((q, i) => (
                                            <div key={i} className="bg-white p-2 rounded text-xs">
                                                <div className="font-medium text-gray-800 truncate">「{q.question}」</div>
                                                <div className="text-purple-600 font-bold">{q.score}点</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            
                            {/* リアルタイムヒント - モバイルでは非表示 */}
                            {!isMobile && questionCount > 2 && scoreHistory.length > 0 && (
                                <div className="mt-3 p-3 bg-blue-50 rounded-lg">
                                    <div className="text-xs text-blue-800">
                                        💡 ヒント: 
                                        {scoreHistory[scoreHistory.length - 1] < 50 ? 
                                            '「なぜ」「どうして」を使って深掘りしてみましょう' :
                                         scoreHistory[scoreHistory.length - 1] < 70 ?
                                            '具体的なエピソードを聞いてみましょう' :
                                            '素晴らしい質問です！この調子で続けましょう'}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* チャットエリア */}
                    <div className="relative flex-1">
                        <div 
                            ref={chatAreaRef}
                            className={`h-full overflow-y-auto p-4 bg-gray-50 ${isMobile ? 'mobile-chat-area smooth-scroll' : ''}`}
                            style={isMobile && keyboardHeight > 0 ? { paddingBottom: `${keyboardHeight + 70}px` } : {}}
                            onScroll={handleScroll}
                        >
                        <div className="max-w-4xl mx-auto space-y-3">
                            {messages.map((msg, index) => (
                                <div 
                                    key={index} 
                                    className={`flex ${msg.type === 'user' ? 'justify-end' : 'justify-start'} fade-in`}
                                >
                                    <div className={`message-bubble ${msg.type}`}>
                                        <div>{msg.content}</div>
                                        {msg.score !== undefined && (
                                            <div className="mt-2 text-xs opacity-70">
                                                スコア: {msg.score}点
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ))}
                            {isTyping && (
                                <div className="flex justify-start">
                                    <div className="message-bubble ai flex gap-1 items-center">
                                        <span className="typing-dot inline-block w-2 h-2 bg-gray-400 rounded-full"></span>
                                        <span className="typing-dot inline-block w-2 h-2 bg-gray-400 rounded-full"></span>
                                        <span className="typing-dot inline-block w-2 h-2 bg-gray-400 rounded-full"></span>
                                    </div>
                                </div>
                            )}
                            <div ref={messagesEndRef} />
                        </div>
                        </div>
                        
                        {/* スクロールボタン - ユーザーが上にスクロールした時のみ表示 */}
                        {!shouldAutoScroll && (
                            <button
                                onClick={scrollToLatest}
                                className="absolute bottom-4 right-4 bg-purple-500 text-white p-3 rounded-full shadow-lg hover:bg-purple-600 transition-all transform hover:scale-110 animate-bounce"
                                aria-label="最新のメッセージへ"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                                </svg>
                            </button>
                        )}
                    </div>
                    
                    {/* 入力エリア */}
                    <div className={`bg-white border-t ${isMobile ? 'mobile-input-area' : 'p-4'}`}>
                        <div className="max-w-4xl mx-auto">
                            <div className="flex gap-2">
                                <input
                                    ref={inputRef}
                                    type="text"
                                    value={currentQuestion}
                                    onChange={(e) => setCurrentQuestion(e.target.value)}
                                    onKeyPress={(e) => {
                                        if (e.key === 'Enter') {
                                            e.preventDefault();
                                            handleSubmitQuestion();
                                        }
                                    }}
                                    onFocus={() => {
                                        // フォーカス時のスクロールは自動スクロール機能に任せる
                                    }}
                                    placeholder="質問を入力..."
                                    disabled={questionCount >= maxQuestions}
                                    autoComplete="off"
                                    autoCorrect="off"
                                    autoCapitalize="off"
                                    spellCheck="false"
                                    className={`flex-1 ${isMobile ? 'mobile-input-field' : 'p-3'} border-2 border-gray-200 rounded-lg focus:border-purple-500 focus:outline-none transition-colors disabled:bg-gray-100`}
                                />
                                <button
                                    onClick={handleSubmitQuestion}
                                    disabled={!currentQuestion.trim() || questionCount >= maxQuestions}
                                    className={`${isMobile ? 'mobile-button px-4' : 'px-6'} py-3 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105`}
                                >
                                    送信
                                </button>
                            </div>
                            {comboCount > 0 && (
                                <div className="mt-2 text-center text-purple-600 font-bold bounce">
                                    🔥 {comboCount}コンボ！
                                </div>
                            )}
                        </div>
                    </div>
                </div>
                );
            };
            
            // AIによる会話分析生成
            const [aiAnalysis, setAiAnalysis] = useState(null);
            const generateAIAnalysis = useCallback(async () => {
                console.log('generateAIAnalysis called', { apiKey: !!apiKey, messagesLength: messages.length });
                if (!apiKey || messages.length === 0) {
                    console.log('Skipping AI analysis - no API key or messages');
                    return;
                }
                
                setIsTyping(true);
                showToast('会話を分析中...', 'info');
                
                const conversationHistory = messages.map(m => 
                    `${m.type === 'user' ? 'インタビュアー' : persona.name}: ${m.content}${m.score ? ` (スコア: ${m.score}点)` : ''}`
                ).join('\n');
                
                const analysisPrompt = `あなたはインタビュー技術の専門家です。
以下のインタビュー会話を分析し、インタビュアー（質問者）の技術を評価してください。

重要: これはインタビュアーの質問技術を向上させるための分析です。
インタビューされた側（${persona.name}）へのアドバイスではありません。

テーマ: ${persona.painPoints && persona.painPoints[0] ? persona.painPoints[0] : '困りごと'}
ペルソナ: ${persona.name} (${persona.age}歳, ${persona.job})

会話履歴:
${conversationHistory}

インタビュアーの質問技術について、以下のJSON形式で分析してください。
重要: 簡潔に要点をまとめてください:

{
  "strengths": [
    {
      "title": "インタビュアーの強み（簡潔に）",
      "detail": "具体的にどの質問が良かったか、なぜ良かったかを詳しく説明"
    }
  ],
  "improvements": [
    {
      "title": "改善すべき点（簡潔に）",
      "detail": "どの質問のどこが問題だったか、どう改善すべきか具体的に説明",
      "practice": "実践的な練習方法を具体的に説明",
      "examples": ["改善された質問例を2-3個", "別のアプローチ例"]
    }
  ],
  "bestQuestion": {
    "question": "インタビュアーが行った最も優れた質問",
    "reason": "なぜその質問が優れていたか"
  },
  "worstQuestion": {
    "question": "インタビュアーの最も改善が必要な質問",
    "improvement": "インタビュアーはこう聞くべきだった"
  },
  "insights": ["インサイト1", "インサイト2", "インサイト3"],
  "overallFeedback": "総合的なフィードバック（100-150文字程度）",
  "nextChallenge": "インタビュアーが次回挑戦すべき具体的な課題",
  "missedOpportunities": [
    {
      "moment": "聞き逃した重要な瞬間",
      "whatToAsk": "その時聞くべきだった質問",
      "reason": "なぜそれが重要だったか"
    }
  ],
  "emotionalIntelligence": {
    "score": 80,
    "feedback": "相手の感情への配慮についてのフィードバック"
  },
  "questioningTechniques": {
    "openQuestions": "オープン質問の使い方評価",
    "followUp": "フォローアップ質問の評価", 
    "probing": "深掘り質問の評価"
  },
  "stats": {
    "avgScore": 50,
    "whyQuestions": 3,
    "openQuestions": 5,
    "avgLength": 30,
    "totalInsights": 2
  },
  "challenges": [
    {
      "title": "インタビュアーが挑戦すべき課題",
      "approach": "インタビュアーが取るべきアプローチ方法",
      "techniques": ["インタビュアーが習得すべき具体的なテクニック"]
    }
  ]
}

注意: すべての分析はインタビュアーの技術向上のためのものです。
${persona.name}へのアドバイスではありません。`;
                
                // リトライロジック
                const maxRetries = 3;
                let retryCount = 0;
                let lastError = null;
                
                while (retryCount < maxRetries) {
                    try {
                        const analysisModel = apiModel || 'deepseek/deepseek-chat-v3.1:free';
                        
                        console.log('Generating analysis with model:', analysisModel);
                        
                        // リトライ時はプロンプトを改善
                        const retryPromptSuffix = retryCount > 0 ? 
                            '\n\n重要: 必ず完全で有効なJSON形式で応答してください。JSONのみを返し、説明文は含めないでください。配列が空の場合でも[]と記述してください。文字列は必ず""で囲んでください。' : '';
                        
                        const response = await safariFetch('https://openrouter.ai/api/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json',
                                'HTTP-Referer': window.location.origin || 'http://localhost',
                                'X-Title': 'Interview Game Analysis'
                            },
                            body: JSON.stringify({
                                model: analysisModel,
                                messages: [
                                    { 
                                        role: 'system', 
                                        content: 'あなたはインタビュー分析の専門家です。与えられた会話を分析し、必ず完全で有効なJSON形式のみで応答してください。説明文や追加のテキストは含めないでください。JSONのプロパティ名は必ずダブルクォートで囲み、文字列値もダブルクォートで囲んでください。配列やオブジェクトの最後の要素にカンマを付けないでください。' 
                                    },
                                    { role: 'user', content: analysisPrompt + retryPromptSuffix }
                                ],
                                temperature: 0.5,
                                max_tokens: analysisModel === 'openrouter/sonoma-sky-alpha' ? 8000 : 4000 // Sonoma: 8000, DeepSeek: 4000
                            })
                        }, 30000); // 30 second timeout for analysis
                        
                        if (!response.ok) {
                            throw new Error(`API Error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                            throw new Error('Invalid API response structure');
                        }
                        
                        const content = data.choices[0].message.content;
                        
                        // JSONパース処理
                        try {
                            let jsonStr = content;
                            
                            // マークダウンコードブロックを除去
                            jsonStr = jsonStr.replace(/```json\n?|```\n?|```/g, '');
                            
                            // JSONオブジェクトを抽出
                            const jsonMatch = jsonStr.match(/\{[\s\S]*\}/);
                            if (jsonMatch) {
                                jsonStr = jsonMatch[0];
                            }
                            
                            // 一般的なJSONエラーを修正
                            jsonStr = jsonStr
                                .replace(/,\s*\}/g, '}') // 末尾のカンマを削除
                                .replace(/,\s*\]/g, ']') // 配列末尾のカンマを削除
                                .replace(/([\[\{,])\s*,/g, '$1') // 連続カンマを削除
                                .replace(/\n\s*\n/g, '\n') // 空行を削除
                                .replace(/[\u0000-\u001F\u007F-\u009F]/g, ''); // 制御文字を削除
                            
                            // 不完全なJSONの修復
                            if (jsonStr.includes('...') || jsonStr.length < 50) {
                                throw new Error('Incomplete JSON response');
                            }
                            
                            const parsedAnalysis = JSON.parse(jsonStr);
                            
                            // 必須フィールドの検証
                            if (!parsedAnalysis.strengths || !parsedAnalysis.improvements) {
                                throw new Error('Missing required fields in analysis');
                            }
                            
                            // statsがない場合はデフォルト値を設定
                            if (!parsedAnalysis.stats) {
                                const analysisData = getAnalysisData();
                                parsedAnalysis.stats = analysisData;
                            }
                            
                            // 配列の検証を追加
                            const validatedAnalysis = {
                                ...parsedAnalysis,
                                strengths: Array.isArray(parsedAnalysis.strengths) ? parsedAnalysis.strengths : [],
                                improvements: Array.isArray(parsedAnalysis.improvements) ? parsedAnalysis.improvements : [],
                                insights: Array.isArray(parsedAnalysis.insights) ? parsedAnalysis.insights : [],
                                challenges: Array.isArray(parsedAnalysis.challenges) ? parsedAnalysis.challenges : []
                            };
                            
                            setAiAnalysis(validatedAnalysis);
                            console.log('AI Analysis parsed successfully:', validatedAnalysis);
                            showToast('分析が完了しました', 'success');
                            break; // 成功したらループを抜ける
                            
                        } catch (parseError) {
                            lastError = parseError;
                            console.error(`Parse attempt ${retryCount + 1} failed:`, parseError);
                            console.error('Raw content:', content);
                            console.error('Cleaned JSON:', jsonStr);
                            
                            // デバッグ: JSONの構造問題を詳細に記録
                            if (parseError.message.includes('JSON')) {
                                console.error('JSON parse error at position:', parseError.message);
                                // 最初の100文字と最後の100文字を表示
                                if (jsonStr && jsonStr.length > 200) {
                                    console.error('JSON start:', jsonStr.substring(0, 100));
                                    console.error('JSON end:', jsonStr.substring(jsonStr.length - 100));
                                }
                            }
                            
                            if (retryCount < maxRetries - 1) {
                                console.log(`Retrying AI analysis (${retryCount + 2}/${maxRetries})...`);
                                showToast(`分析を再試行中... (${retryCount + 2}/${maxRetries})`, 'info');
                                retryCount++;
                                await new Promise(resolve => setTimeout(resolve, 1000)); // 1秒待機
                            } else {
                                throw parseError;
                            }
                        }
                        
                    } catch (error) {
                        lastError = error;
                        retryCount++;
                        
                        if (retryCount >= maxRetries) {
                            console.error('All analysis attempts failed:', error);
                            showToast('AI分析に失敗しました。手動分析を使用します', 'warning');
                            
                            // フォールバック: 手動分析を使用
                            const manualAnalysis = generateDetailedAnalysis();
                            setAiAnalysis({
                                ...manualAnalysis,
                                overallFeedback: '自動分析に失敗したため、基本的な分析結果を表示しています。',
                                fromManual: true
                            });
                            break;
                        }
                        
                        console.log(`Retrying due to API error (${retryCount + 1}/${maxRetries})...`);
                        await new Promise(resolve => setTimeout(resolve, 2000)); // 2秒待機
                    }
                }
                
                setIsTyping(false);
            }, [apiKey, apiModel, messages, persona, showToast, getAnalysisData, generateDetailedAnalysis, insights, bestQuestions]);
            
            // 結果画面
            const renderResult = () => {
                // AIAnalysisがある場合はそれを使用、なければ手動分析を使用
                let analysis = aiAnalysis;
                
                // AI分析が不完全な場合は手動分析で補完
                if (!analysis || !analysis.stats) {
                    const manualAnalysis = generateDetailedAnalysis();
                    if (analysis) {
                        // AI分析の一部が使える場合はマージ（AI分析を優先）
                        analysis = {
                            ...manualAnalysis,
                            ...analysis,
                            stats: analysis.stats || manualAnalysis.stats,
                            // 配列は確実に存在するようにする
                            strengths: analysis.strengths || manualAnalysis.strengths || [],
                            improvements: analysis.improvements || manualAnalysis.improvements || [],
                            insights: analysis.insights || manualAnalysis.insights || [],
                            challenges: analysis.challenges || manualAnalysis.challenges || []
                        };
                    } else {
                        analysis = manualAnalysis;
                    }
                }
                
                // データの検証とデフォルト値の設定
                analysis = {
                    ...analysis,
                    strengths: Array.isArray(analysis.strengths) ? analysis.strengths : [],
                    improvements: Array.isArray(analysis.improvements) ? analysis.improvements : [],
                    insights: Array.isArray(analysis.insights) ? analysis.insights : [],
                    challenges: Array.isArray(analysis.challenges) ? analysis.challenges : [],
                    stats: analysis.stats || { avgScore: 0, whyQuestions: 0, openQuestions: 0, avgLength: 0, totalInsights: 0 }
                };
                
                // デバッグ用ログ
                console.log('Rendering analysis result:', {
                    hasStrengths: analysis.strengths && analysis.strengths.length > 0,
                    hasImprovements: analysis.improvements && analysis.improvements.length > 0,
                    hasInsights: analysis.insights && analysis.insights.length > 0,
                    hasChallenges: analysis.challenges && analysis.challenges.length > 0,
                    improvements: analysis.improvements
                });
                
                // insightsとbestQuestionsを分析結果から取得、なければstateから取得
                const displayInsights = analysis.insights || insights;
                const displayBestQuestions = analysis.bestQuestion ? 
                    [{ question: analysis.bestQuestion.question, score: 90 }] : bestQuestions;
                
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-100 to-pink-100 p-4 overflow-y-auto">
                        <div className="max-w-6xl mx-auto space-y-6">
                            {/* スコアサマリー */}
                            <div className="bg-white rounded-2xl shadow-2xl p-8 fade-in">
                                <div className="text-center mb-8">
                                    <div className="text-6xl font-bold mb-4 gradient-text">
                                        {calculateRank()}
                                    </div>
                                    <div className="text-3xl font-bold mb-2">
                                        {currentScore} pts
                                    </div>
                                    <div className="text-gray-600">
                                        {questionCount}回の質問 | 平均スコア: {analysis.stats.avgScore}点
                                    </div>
                                </div>
                                
                                {/* 統計情報 */}
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                                    <div className="text-center p-3 bg-purple-50 rounded-lg">
                                        <div className="text-2xl font-bold text-purple-600">{analysis.stats.whyQuestions}</div>
                                        <div className="text-xs text-gray-600">なぜ質問</div>
                                    </div>
                                    <div className="text-center p-3 bg-blue-50 rounded-lg">
                                        <div className="text-2xl font-bold text-blue-600">{analysis.stats.openQuestions}</div>
                                        <div className="text-xs text-gray-600">オープン質問</div>
                                    </div>
                                    <div className="text-center p-3 bg-green-50 rounded-lg">
                                        <div className="text-2xl font-bold text-green-600">{analysis.stats.avgLength}</div>
                                        <div className="text-xs text-gray-600">平均文字数</div>
                                    </div>
                                    <div className="text-center p-3 bg-yellow-50 rounded-lg">
                                        <div className="text-2xl font-bold text-yellow-600">{analysis.stats.totalInsights}</div>
                                        <div className="text-xs text-gray-600">インサイト</div>
                                    </div>
                                    <div className="text-center p-3 bg-pink-50 rounded-lg">
                                        <div className="text-2xl font-bold text-pink-600">{bestQuestions.length}</div>
                                        <div className="text-xs text-gray-600">優秀質問</div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* ベスト質問とインサイト */}
                            <div className="grid md:grid-cols-2 gap-6">
                                <div className="bg-white rounded-xl shadow-lg p-6">
                                    <h3 className="font-bold text-lg mb-4 flex items-center">
                                        <span className="text-2xl mr-2">🏆</span>
                                        ベスト質問 TOP3
                                    </h3>
                                    <div className="space-y-3">
                                        {displayBestQuestions.slice(0, 3).map((q, i) => (
                                            <div key={i} className="p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg">
                                                <div className="flex justify-between items-start mb-1">
                                                    <span className="text-lg font-bold text-purple-600">#{i + 1}</span>
                                                    <span className="font-bold text-purple-600">{q.score}pts</span>
                                                </div>
                                                <div className="text-sm text-gray-700">{q.question}</div>
                                            </div>
                                        ))}
                                        {displayBestQuestions.length === 0 && (
                                            <div className="text-gray-500 text-center py-4">まだ高得点の質問がありません</div>
                                        )}
                                    </div>
                                </div>
                                
                                <div className="bg-white rounded-xl shadow-lg p-6">
                                    <h3 className="font-bold text-lg mb-4 flex items-center">
                                        <span className="text-2xl mr-2">💡</span>
                                        発見したインサイト
                                    </h3>
                                    <div className="space-y-3">
                                        {displayInsights.map((insight, i) => (
                                            <div key={i} className="p-3 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-lg">
                                                <div className="text-sm text-gray-700">{insight}</div>
                                            </div>
                                        ))}
                                        {displayInsights.length === 0 && (
                                            <div className="text-gray-500 text-center py-4">
                                                インサイトを発見するには、より深い「なぜ」の質問が必要です
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                            
                            {/* 詳細分析 */}
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <h3 className="font-bold text-xl mb-6 text-center">📊 詳細な分析とフィードバック</h3>
                                
                                {/* 強み */}
                                {analysis.strengths && analysis.strengths.length > 0 && (
                                    <div className="mb-6">
                                        <h4 className="font-bold text-lg mb-3 text-green-600">✨ あなたの強み</h4>
                                        <div className="space-y-3">
                                            {analysis.strengths.map((strength, i) => (
                                                <div key={i} className="p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                    <div className="font-bold text-green-700 mb-1">{strength.title}</div>
                                                    <div className="text-sm text-gray-700">{strength.detail}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* ベスト質問とワースト質問 */}
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    {analysis.bestQuestion && (
                                        <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                            <h5 className="font-bold text-blue-700 mb-2">🏆 最も優れた質問</h5>
                                            <div className="text-sm text-gray-700 italic mb-2">「{analysis.bestQuestion.question}」</div>
                                            <div className="text-xs text-gray-600">{analysis.bestQuestion.reason}</div>
                                        </div>
                                    )}
                                    {analysis.worstQuestion && (
                                        <div className="p-4 bg-red-50 rounded-lg border-l-4 border-red-500">
                                            <h5 className="font-bold text-red-700 mb-2">💭 改善が必要な質問</h5>
                                            <div className="text-sm text-gray-700 italic mb-2">「{analysis.worstQuestion.question}」</div>
                                            <div className="text-xs text-gray-600">{analysis.worstQuestion.improvement}</div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* 改善点 */}
                                {analysis.improvements && analysis.improvements.length > 0 && (
                                    <div className="mb-6">
                                        <h4 className="font-bold text-lg mb-3 text-orange-600">📈 改善ポイント</h4>
                                        <div className="space-y-3">
                                            {analysis.improvements.map((improvement, i) => (
                                                <div key={i} className="p-4 bg-orange-50 rounded-lg border-l-4 border-orange-500">
                                                    <div className="font-bold text-orange-700 mb-1">{improvement.title}</div>
                                                    <div className="text-sm text-gray-700 mb-2">{improvement.detail}</div>
                                                    {improvement.practice && (
                                                        <div className="p-3 bg-white rounded-md">
                                                            <div className="text-xs font-bold text-orange-600 mb-1">💪 練習方法</div>
                                                            <div className="text-xs text-gray-600">{improvement.practice}</div>
                                                            {improvement.examples && improvement.examples.length > 0 && (
                                                                <div className="mt-2">
                                                                    <div className="text-xs font-bold text-orange-600 mb-1">📝 質問例</div>
                                                                    <div className="space-y-1">
                                                                        {improvement.examples.map((example, i) => (
                                                                            <div key={i} className="text-xs text-gray-600 pl-2">
                                                                                {example}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* 聞き逃した機会 */}
                                {analysis.missedOpportunities && analysis.missedOpportunities.length > 0 && (
                                    <div className="mb-6">
                                        <h4 className="font-bold text-lg mb-3 text-yellow-600">⚠️ 聞き逃した重要な機会</h4>
                                        <div className="space-y-3">
                                            {analysis.missedOpportunities.map((opportunity, i) => (
                                                <div key={i} className="p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div className="font-bold text-yellow-700 mb-1">瞬間: {opportunity.moment}</div>
                                                    <div className="text-sm text-gray-700 mb-1">聞くべきだった質問: 「{opportunity.whatToAsk}」</div>
                                                    <div className="text-xs text-gray-600">理由: {opportunity.reason}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* 感情知性評価 */}
                                {analysis.emotionalIntelligence && (
                                    <div className="mb-6 p-4 bg-pink-50 rounded-lg border-l-4 border-pink-500">
                                        <h4 className="font-bold text-pink-700 mb-2">💗 感情への配慮スコア: {analysis.emotionalIntelligence.score}/100</h4>
                                        <div className="text-sm text-gray-700">{analysis.emotionalIntelligence.feedback}</div>
                                    </div>
                                )}
                                
                                {/* 質問技術の詳細評価 */}
                                {analysis.questioningTechniques && (
                                    <div className="mb-6">
                                        <h4 className="font-bold text-lg mb-3 text-teal-600">🎯 質問技術の詳細評価</h4>
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                            <div className="p-3 bg-teal-50 rounded-lg">
                                                <div className="font-bold text-teal-700 text-sm mb-1">オープン質問</div>
                                                <div className="text-xs text-gray-600">{analysis.questioningTechniques.openQuestions}</div>
                                            </div>
                                            <div className="p-3 bg-teal-50 rounded-lg">
                                                <div className="font-bold text-teal-700 text-sm mb-1">フォローアップ</div>
                                                <div className="text-xs text-gray-600">{analysis.questioningTechniques.followUp}</div>
                                            </div>
                                            <div className="p-3 bg-teal-50 rounded-lg">
                                                <div className="font-bold text-teal-700 text-sm mb-1">深掘り力</div>
                                                <div className="text-xs text-gray-600">{analysis.questioningTechniques.probing}</div>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {/* 総合フィードバック */}
                                {analysis.overallFeedback && (
                                    <div className="mb-6 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 rounded-lg border-l-4 border-indigo-500">
                                        <h4 className="font-bold text-indigo-700 mb-2">💡 総合フィードバック</h4>
                                        <div className="text-sm text-gray-700">{analysis.overallFeedback}</div>
                                    </div>
                                )}
                                
                                {/* 次回の課題 */}
                                {analysis.challenges && analysis.challenges.length > 0 && (
                                <div>
                                    <h4 className="font-bold text-lg mb-3 text-purple-600">🎯 次回チャレンジする課題</h4>
                                    <div className="space-y-3">
                                        {analysis.challenges.map((challenge, i) => (
                                            <div key={i} className="p-4 bg-purple-50 rounded-lg border-l-4 border-purple-500">
                                                <div className="font-bold text-purple-700 mb-1">{challenge.title}</div>
                                                <div className="text-sm text-gray-700">{challenge.approach}</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                )}
                            </div>
                            
                            {/* アクションボタン */}
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <div className="flex gap-3">
                                    <button
                                        onClick={resetGame}
                                        className="flex-1 py-3 px-6 bg-gray-100 text-gray-700 rounded-lg font-medium hover:bg-gray-200 transition-colors"
                                    >
                                        メニューに戻る
                                    </button>
                                    <button
                                        onClick={() => {
                                            const text = `デザイン思考インタビューゲーム
ランク: ${calculateRank()}
総合スコア: ${currentScore}pts
平均: ${analysis.stats.avgScore}点/質問
なぜ質問: ${analysis.stats.whyQuestions}回
オープン質問: ${analysis.stats.openQuestions}回`;
                                            if (navigator.share) {
                                                navigator.share({
                                                    title: 'インタビューゲーム結果',
                                                    text: text
                                                });
                                            } else {
                                                navigator.clipboard.writeText(text);
                                                showToast('結果をコピーしました', 'success');
                                            }
                                        }}
                                        className="flex-1 py-3 px-6 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-lg font-medium hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105"
                                    >
                                        結果をシェア
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };
            
            // ペルソナ確認画面
            const renderPersona = () => (
                <div className="min-h-screen flex items-center justify-center p-4 bg-gradient-to-br from-purple-100 to-pink-100">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-2xl w-full fade-in">
                        <h2 className="text-2xl font-bold text-center mb-6 gradient-text">
                            インタビュー相手のプロフィール
                        </h2>
                        
                        {persona && (
                            <div className="space-y-6">
                                {/* 基本情報カード */}
                                <div className="bg-gradient-to-r from-purple-50 to-pink-50 rounded-xl p-6">
                                    <div className="flex items-center mb-4">
                                        <div className="w-20 h-20 bg-gradient-to-br from-purple-400 to-pink-400 rounded-full flex items-center justify-center text-white text-3xl font-bold">
                                            {persona.name.charAt(0)}
                                        </div>
                                        <div className="ml-4">
                                            <h3 className="text-2xl font-bold text-gray-800">{persona.name}</h3>
                                            <p className="text-gray-600">{persona.age}歳 / {persona.gender}</p>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div className="bg-white rounded-lg p-3">
                                            <div className="text-xs text-gray-500 mb-1">職業</div>
                                            <div className="font-medium text-gray-800">{persona.job}</div>
                                        </div>
                                        <div className="bg-white rounded-lg p-3">
                                            <div className="text-xs text-gray-500 mb-1">居住地</div>
                                            <div className="font-medium text-gray-800">{persona.location}</div>
                                        </div>
                                        <div className="bg-white rounded-lg p-3">
                                            <div className="text-xs text-gray-500 mb-1">家族構成</div>
                                            <div className="font-medium text-gray-800">{persona.family}</div>
                                        </div>
                                        <div className="bg-white rounded-lg p-3">
                                            <div className="text-xs text-gray-500 mb-1">趣味</div>
                                            <div className="font-medium text-gray-800">{persona.hobbies.join('、')}</div>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* インタビューテーマ */}
                                <div className="bg-blue-50 rounded-xl p-4">
                                    <h4 className="font-bold text-blue-800 mb-2">今回のインタビューテーマ</h4>
                                    <p className="text-gray-700 text-lg">{persona.painPoints && persona.painPoints[0] ? persona.painPoints[0] : '困りごと'}</p>
                                </div>
                                
                                {/* 背景情報（AI生成の場合） */}
                                {(persona.background || persona.currentSituation) && (
                                    <div className="bg-green-50 rounded-xl p-4">
                                        <h4 className="font-bold text-green-800 mb-2">📖 人物背景</h4>
                                        {persona.background && (
                                            <p className="text-sm text-gray-700 mb-2">{persona.background}</p>
                                        )}
                                        {persona.currentSituation && (
                                            <p className="text-sm text-gray-700">{persona.currentSituation}</p>
                                        )}
                                        {persona.personality?.traits && persona.personality.traits.length > 0 && (
                                            <div className="mt-2 pt-2 border-t border-green-200">
                                                <span className="text-xs font-bold text-green-700">性格特性: </span>
                                                <span className="text-xs text-gray-600">{persona.personality.traits.join('、')}</span>
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                {/* ヒント */}
                                <div className="bg-yellow-50 rounded-xl p-4">
                                    <h4 className="font-bold text-yellow-800 mb-2">💡 インタビューのヒント</h4>
                                    <ul className="text-sm text-gray-700 space-y-1">
                                        <li>• 相手の背景を意識して質問しましょう</li>
                                        <li>• {persona.age}歳の{persona.gender}としての視点を考慮しましょう</li>
                                        <li>• {persona.job}という職業特有の課題があるかもしれません</li>
                                        <li>• 「なぜ」を深掘りして本質的なニーズを探りましょう</li>
                                    </ul>
                                    
                                    {persona.painPoints && persona.painPoints.length > 0 && (
                                        <div className="mt-3 pt-3 border-t border-yellow-200">
                                            <div className="text-xs font-bold text-yellow-700 mb-1">
                                                🎯 このテーマで想定される課題
                                            </div>
                                            <div className="text-xs text-gray-600">
                                                {persona.painPoints.join('、')}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {persona.hiddenNeeds && persona.hiddenNeeds.length > 0 && (
                                        <div className="mt-2">
                                            <div className="text-xs font-bold text-yellow-700 mb-1">
                                                🔍 発見すべき潜在ニーズ
                                            </div>
                                            <div className="text-xs text-gray-600">
                                                深い質問で見つけてみましょう（ヒント: {persona.hiddenNeeds.length}個）
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* アクションボタン */}
                                <div className="flex gap-3">
                                    <button
                                        onClick={async () => {
                                            const finalPainPoint = customPainPoint || selectedPainPoint || 
                                                (persona.painPoints && persona.painPoints[0] ? persona.painPoints[0] : '困りごと');
                                            setIsGeneratingPersona(true);
                                            try {
                                                const aiPersona = await generatePersonaWithAI(finalPainPoint);
                                                if (aiPersona) {
                                                    setPersona(aiPersona);
                                                } else {
                                                    setPersona(generatePersona(finalPainPoint));
                                                }
                                            } finally {
                                                setIsGeneratingPersona(false);
                                            }
                                        }}
                                        disabled={isGeneratingPersona}
                                        className={`flex-1 py-3 px-6 ${
                                            !isGeneratingPersona
                                                ? 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        } rounded-lg font-medium transition-colors`}
                                    >
                                        {isGeneratingPersona ? '生成中...' : '別の人を選ぶ'}
                                    </button>
                                    <button
                                        onClick={startInterview}
                                        disabled={isGeneratingPersona}
                                        className={`flex-1 py-3 px-6 ${
                                            !isGeneratingPersona
                                                ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600 transform hover:scale-105'
                                                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        } rounded-lg font-medium transition-all`}
                                    >
                                        インタビューを開始
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
            
            return (
                <div className={`min-h-screen bg-gradient-to-br ${getMoodColor()} transition-all duration-1000`}>
                    {/* ローディングオーバーレイ */}
                    {isGeneratingPersona && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg p-8 flex flex-col items-center">
                                <div className="animate-spin rounded-full h-12 w-12 border-4 border-purple-500 border-t-transparent mb-4"></div>
                                <div className="text-lg font-semibold text-gray-800">ペルソナを生成中...</div>
                                <div className="text-sm text-gray-600 mt-2">少しお待ちください</div>
                            </div>
                        </div>
                    )}
                    
                    {gameState === 'menu' && renderMenu()}
                    {gameState === 'persona' && renderPersona()}
                    {gameState === 'playing' && renderGame()}
                    {gameState === 'result' && renderResult()}
                    
                    {/* パーティクルエフェクト */}
                    {showParticles && (
                        <div className="fixed inset-0 pointer-events-none">
                            {[...Array(20)].map((_, i) => (
                                <div
                                    key={i}
                                    className="particle"
                                    style={{
                                        left: `${Math.random() * 100}%`,
                                        top: `${Math.random() * 100}%`,
                                        '--x': `${(Math.random() - 0.5) * 200}px`,
                                        '--y': `${(Math.random() - 0.5) * 200}px`,
                                        animationDelay: `${Math.random() * 0.5}s`
                                    }}
                                >
                                    ⭐
                                </div>
                            ))}
                        </div>
                    )}
                    
                    {/* トースト通知 */}
                    <div className="fixed bottom-4 right-4 space-y-2 z-50">
                        {toasts.map(toast => (
                            <div
                                key={toast.id}
                                className={`toast ${
                                    toast.type === 'success' ? 'bg-green-500' :
                                    toast.type === 'warning' ? 'bg-yellow-500' :
                                    toast.type === 'error' ? 'bg-red-500' :
                                    'bg-gray-700'
                                } text-white px-4 py-2 rounded-lg shadow-lg`}
                            >
                                {toast.message}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };
        
        // アプリケーションのレンダリング
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<InterviewGame />);
    </script>
</body>
</html>
